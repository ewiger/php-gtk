/* vim: set ft=cpp: */
%%
headers
#include "ext/standard/file.h"
%%
ignore-glob
	*_get_type
	gtk_marshal_*
	gtk_arg_*
	gtk_args_*
	gtk_signal_connect*
	gtk_signal_add_emission_hook*
	gtk_signal_new*
	gtk_init_add_*
	gtk_quit_add_*
	gtk_timeout_add_*
	gtk_idle_add_*
	gtk_accelerator_*
	gtk_target_list_*
%%
ignore
	gtk_init
	gtk_init_check
	gtk_exit
	gtk_set_locale
	gtk_accel_group_new
	gtk_accel_group_ref
	gtk_accel_group_unref
	gtk_accel_group_lock
	gtk_accel_group_unlock
	gtk_accel_groups_activate
	gtk_accel_group_activate
	gtk_accel_group_attach
	gtk_accel_group_detach
	gtk_accel_group_get_entry
	gtk_accel_group_lock_entry
	gtk_accel_group_unlock_entry
	gtk_accel_group_add
	gtk_accel_group_remove
	gtk_accel_group_handle_add
	gtk_accel_group_handle_remove
	gtk_accel_group_create_add
	gtk_accel_group_create_remove
	gtk_accel_groups_from_object
	gtk_accel_group_entries_from_object
	gtk_signal_set_funcs
	gtk_signal_lookup
	gtk_signal_disconnect_by_func
	gtk_signal_disconnect_by_data
	gtk_signal_handler_block_by_func
	gtk_signal_handler_block_by_data
	gtk_signal_handler_unblock_by_func
	gtk_signal_handler_unblock_by_data
	gtk_signal_handler_pending_by_func
	gtk_signal_n_emissions
	gtk_signal_n_emissions_by_name
	gtk_signal_name
	gtk_signal_remove_emission_hook
	gtk_signal_query
	gtk_signal_emit
	gtk_signal_emit_by_name
	gtk_signal_emitv
	gtk_signal_emitv_by_name
	gtk_quit_remove_by_data
	gtk_idle_remove_by_data
	gtk_object_weakref
	gtk_object_weakunref
	gtk_object_get
	gtk_object_getv
	gtk_object_set
	gtk_object_setv
	gtk_object_set_data_full
	gtk_object_set_user_data
	gtk_object_get_user_data
	gtk_object_set_data_by_id
	gtk_object_set_data_by_id_full
	gtk_object_get_data_by_id
	gtk_object_remove_data_by_id
	gtk_object_remove_no_notify_by_id
	gtk_object_arg_set
	gtk_object_arg_get
	gtk_trace_referencing
	gtk_widget_get
	gtk_widget_getv
	gtk_widget_set
	gtk_widget_setv
	gtk_container_get_toplevels
	gtk_container_add_child_arg_type
	gtk_container_query_child_args
	gtk_container_child_args_collect
	gtk_container_child_arg_get_info
	gtk_container_foreach
	gtk_container_foreach_full
	gtk_container_forall
	gtk_container_child_getv
	gtk_container_child_setv
	gtk_container_add_with_args
	gtk_container_addv
	gtk_container_child_set
	gtk_container_arg_set
	gtk_container_arg_get
	gtk_progress_bar_new
	gtk_clist_set_row_data_full
	gtk_window_add_embedded_xid
	gtk_window_remove_embedded_xid
	gtk_range_trough_click
	gtk_range_default_htrough_click
	gtk_range_default_vtrough_click
	gtk_tooltips_data_get
	gtk_type_check_object_cast
	gtk_type_check_class_cast
	gtk_type_register_enum
	gtk_type_register_flags
	gtk_preview_uninit
	gtk_item_factory_create_item
	gtk_item_factory_delete_entry
	gtk_item_factory_delete_entries
	gtk_item_factory_popup_with_data
	gtk_item_factory_popup_data
	gtk_item_factory_set_translate_func
	gtk_item_factory_create_items_ac
	gtk_item_factory_create_menu_entries
	gtk_menu_attach_to_widget
	gtk_radio_menu_item_group
	gtk_radio_menu_item_set_group
	gtk_radio_button_group
	gtk_radio_button_set_group
	gtk_style_new
%%
ignore
	gtk_object_new
	gtk_object_newv
	gtk_object_query_args
	gtk_object_add_arg_type
	gtk_object_args_collect
	gtk_object_arg_get_info
	gtk_widget_new
	gtk_widget_newv
%%
ignore
	gtk_key_snooper_install
	gtk_key_snooper_remove
	gtk_get_current_event
	gtk_get_event_widget
	gtk_propagate_event
%%
ignore
	GtkPrivateFlags
%%
ignore
	gtk_container_dequeue_resize_handler
	gtk_window_reposition
%%
ignore
	gtk_draw_flat_box
	gtk_draw_check
	gtk_draw_option
	gtk_draw_cross
	gtk_draw_ramp
	gtk_draw_tab
	gtk_draw_shadow_gap
	gtk_draw_box_gap
	gtk_draw_extension
	gtk_draw_focus
	gtk_draw_slider
	gtk_draw_handle
%%
override gtk_true
PHP_FUNCTION(wrap_gtk_true)
{
	RETURN_TRUE;
}
%%
override gtk_false
PHP_FUNCTION(wrap_gtk_false)
{
	RETURN_FALSE;
}
%%
override gtk_timeout_add
PHP_FUNCTION(wrap_gtk_timeout_add)
{
	guint32 interval;
	zval *callback = NULL;
	zval *extra;
	zval *data;
	char *callback_filename;
	uint callback_lineno;

	if (ZEND_NUM_ARGS() < 2) {
		php_error(E_WARNING, "%s() requires at least 2 arguments, %d given",
				  get_active_function_name(), ZEND_NUM_ARGS());
		return;
	}

	if (!php_gtk_parse_args(2, "iV", &interval, &callback))
		return;

	callback_filename = zend_get_executed_filename(ELS_C);
	callback_lineno = zend_get_executed_lineno(ELS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 2, ZEND_NUM_ARGS());
	data = php_gtk_build_value("(VNsi)", callback, extra, callback_filename, callback_lineno);
	RETURN_LONG(gtk_timeout_add_full(interval, NULL,
									 (GtkCallbackMarshal)php_gtk_handler_marshal,
									 data, php_gtk_destroy_notify));
}
%%
override gtk_idle_add
PHP_FUNCTION(wrap_gtk_idle_add)
{
	zval *callback = NULL;
	zval *extra;
	zval *data;
	char *callback_filename;
	uint callback_lineno;

	if (ZEND_NUM_ARGS() < 1) {
		php_error(E_WARNING, "%s() requires at least 1 argument, %d given",
				  get_active_function_name(), ZEND_NUM_ARGS());
		return;
	}

	if (!php_gtk_parse_args(1, "V", &callback))
		return;

	callback_filename = zend_get_executed_filename(ELS_C);
	callback_lineno = zend_get_executed_lineno(ELS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 1, ZEND_NUM_ARGS());
	data = php_gtk_build_value("(VNsi)", callback, extra, callback_filename, callback_lineno);
	RETURN_LONG(gtk_idle_add_full(GTK_PRIORITY_DEFAULT, NULL,
								 (GtkCallbackMarshal)php_gtk_handler_marshal,
								 data, php_gtk_destroy_notify));
}
%%
override gtk_quit_add
PHP_FUNCTION(wrap_gtk_quit_add)
{
	gint main_level;
	zval *callback = NULL;
	zval *extra;
	zval *data;
	char *callback_filename;
	uint callback_lineno;

	if (ZEND_NUM_ARGS() < 2) {
		php_error(E_WARNING, "%s() requires at least 2 arguments, %d given",
				  get_active_function_name(), ZEND_NUM_ARGS());
		return;
	}

	if (!php_gtk_parse_args(2, "iV", &main_level, &callback))
		return;

	callback_filename = zend_get_executed_filename(ELS_C);
	callback_lineno = zend_get_executed_lineno(ELS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 2, ZEND_NUM_ARGS());
	data = php_gtk_build_value("(VNsi)", callback, extra, callback_filename, callback_lineno);
	RETURN_LONG(gtk_quit_add_full(main_level, NULL,
								  (GtkCallbackMarshal)php_gtk_handler_marshal,
								  data, php_gtk_destroy_notify));
}
%%
override gtk_input_add_full
PHP_FUNCTION(wrap_gtk_input_add_full)
{
	zval *source_rsrc;
	int rsrc_type;
	int *source;
    GdkInputCondition condition;
	zval *callback = NULL;
	zval *extra, *data;
	char *callback_filename;
	uint callback_lineno;

	if (ZEND_NUM_ARGS() < 3) {
		php_error(E_WARNING, "%s() requires at least 3 arguments, %d given",
				  get_active_function_name(), ZEND_NUM_ARGS());
		return;
	}

	if (!php_gtk_parse_args(3, "riV", &source_rsrc, &condition, &callback))
		return;

	source = zend_list_find(Z_LVAL_P(source_rsrc), &rsrc_type);
	if (!source || rsrc_type != php_file_le_fopen()) {
		php_error(E_WARNING, "%s() expects argument 1 to be a valid filehandle resource", get_active_function_name());
		return;
	}
	
	callback_filename = zend_get_executed_filename(ELS_C);
	callback_lineno = zend_get_executed_lineno(ELS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 3, ZEND_NUM_ARGS());
	data = php_gtk_build_value("(VNsi)", callback, extra, callback_filename, callback_lineno);
	RETURN_LONG(gtk_input_add_full(*source, condition, NULL,
								 (GtkCallbackMarshal)php_gtk_input_marshal,
								 data, php_gtk_destroy_notify));
}
%%
override gtk_signal_connect
static void wrap_gtk_signal_connect_impl(INTERNAL_FUNCTION_PARAMETERS, int pass_object, int after)
{
	char *name = NULL;
	zval *callback = NULL;
	zval *extra;
	zval *data;
	char *callback_filename;
	uint callback_lineno;

	NOT_STATIC_METHOD();

	if (ZEND_NUM_ARGS() < 2) {
		php_error(E_WARNING, "%s() requires at least 2 arguments, %d given",
				  get_active_function_name(), ZEND_NUM_ARGS());
		return;
	}

	if (!php_gtk_parse_args(2, "sV", &name, &callback))
		return;

	callback_filename = zend_get_executed_filename(ELS_C);
	callback_lineno = zend_get_executed_lineno(ELS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 2, ZEND_NUM_ARGS());
	data = php_gtk_build_value("(VNisi)", callback, extra, pass_object, callback_filename, callback_lineno);
	RETURN_LONG(gtk_signal_connect_full(PHP_GTK_GET(this_ptr), name, NULL,
										(GtkCallbackMarshal)php_gtk_callback_marshal,
										data, php_gtk_destroy_notify, FALSE, after));
}

PHP_FUNCTION(wrap_gtk_signal_connect)
{
	wrap_gtk_signal_connect_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 0);
}
%%
override gtk_signal_connect_object
PHP_FUNCTION(wrap_gtk_signal_connect_object)
{
	wrap_gtk_signal_connect_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}
%%
override gtk_signal_connect_after
PHP_FUNCTION(wrap_gtk_signal_connect_after)
{
	wrap_gtk_signal_connect_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 1);
}
%%
override gtk_signal_connect_object_after
PHP_FUNCTION(wrap_gtk_signal_connect_object_after)
{
	wrap_gtk_signal_connect_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);
}
%%
override gtk_object_set
PHP_FUNCTION(wrap_gtk_object_set)
{
}
%%
override gtk_object_get
PHP_FUNCTION(wrap_gtk_object_get)
{
	char *name;
	GtkArg garg;
	zval *ret;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &name))
		return;

	garg.type = GTK_TYPE_INVALID;
	garg.name = name;
	gtk_object_getv(PHP_GTK_GET(this_ptr), 1, &garg);

	if (garg.type == GTK_TYPE_INVALID) {
		php_error(E_WARNING, "%s(): invalid arg '%s'",
				  get_active_function_name(), name);
		return;
	}
	
	ret = php_gtk_arg_as_value(&garg);
	if (ret == NULL) {
		php_error(E_WARNING, "%s() couldn't translate type");
		return;
	}

	zval_add_ref(&ret);
	*return_value = *ret;
	FREE_ZVAL(ret);
}
%%
override gtk_object_set_data
PHP_FUNCTION(wrap_gtk_object_set_data)
{
	char *key;
	zval *data;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "sV", &key, &data))
		return;

	zval_add_ref(&data);
	gtk_object_set_data_full(PHP_GTK_GET(this_ptr), key, data, php_gtk_destroy_notify);
}
%%
override gtk_object_get_data
PHP_FUNCTION(wrap_gtk_object_get_data)
{
	char *key;
	zval *data;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &key))
		return;

	data = gtk_object_get_data(PHP_GTK_GET(this_ptr), key);
	if (data) {
		*return_value = *data;
		zval_copy_ctor(return_value);
	}
}
%%
override gtk_widget_intersect
PHP_FUNCTION(wrap_gtk_widget_intersect)
{
	GdkRectangle area, intersection;
	
	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "iiii", &(area.x), &(area.y), &(area.width), &(area.height)))
		return;

	if (gtk_widget_intersect(GTK_WIDGET(PHP_GTK_GET(this_ptr)), &area, &intersection)) {
		array_init(return_value);
		*return_value = *php_gtk_build_value("(iiii)", area.x, area.y, area.width, area.height);
	}
}
%%
override gtk_menu_attach_to_widget
static void gtk_menu_detacher(GtkWidget *widget, GtkMenu *menu)
{
	GtkMenu *remove_menu;
	g_return_if_fail(widget != NULL);
	g_return_if_fail(GTK_IS_MENU(widget));
	
	remove_menu = GTK_MENU(widget);
//	g_return_if_fail(remove_menu->menu == (GtkWidget*) menu);
	
//	remove_menu->menu = NULL;
}

PHP_FUNCTION(wrap_gtk_menu_attach_to_widget)
{
	zval *php_widget = NULL;
	GtkWidget* obj = NULL;

	NOT_STATIC_METHOD();
	
	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "O", &php_widget, gtk_widget_ce))
		return;

	gtk_menu_attach_to_widget(GTK_MENU(PHP_GTK_GET(this_ptr)), GTK_WIDGET(PHP_GTK_GET(php_widget)), gtk_menu_detacher);
}
%%
override gtk_curve_get_vector
PHP_FUNCTION(wrap_gtk_curve_get_vector)
{
	int veclen = -1, i;
	gfloat *vector = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|i", &veclen))
		return;

	if (veclen < 0)
		veclen = GTK_CURVE(PHP_GTK_GET(this_ptr))->num_points;
	vector = emalloc(sizeof(gfloat) * veclen);
	gtk_curve_get_vector(GTK_CURVE(PHP_GTK_GET(this_ptr)), veclen, vector);
	array_init(return_value);
	for (i = 0; i < veclen; i++)
		add_index_double(return_value, i, vector[i]);
	efree(vector);
}
%%
override gtk_curve_set_vector
PHP_FUNCTION(wrap_gtk_curve_set_vector)
{
	int veclen, i;
	gfloat *vector = NULL;
	zval *php_vector, **temp_vector;
	HashTable *target_hash;
	
	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &php_vector))
		return;

	target_hash = HASH_OF(php_vector);
	veclen = zend_hash_num_elements(target_hash);
	vector = emalloc(sizeof(gfloat) * veclen);
	zend_hash_internal_pointer_reset(target_hash);
	i = 0;
	while (zend_hash_get_current_data(target_hash, (void **)&temp_vector) == SUCCESS) {
		vector[i++] = Z_DVAL_PP(temp_vector);
		zend_hash_move_forward(target_hash);
	}
	
	gtk_curve_set_vector(GTK_CURVE(PHP_GTK_GET(this_ptr)), veclen, vector);
	RETURN_TRUE;
}
%%
overrides gtk_rc_get_default_files
PHP_FUNCTION(wrap_gtk_rc_get_default_files)
{
	gchar **ret;
	
	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	ret = gtk_rc_get_default_files();
	if (ret) {
		array_init(return_value);
		while (*ret) {
			add_next_index_string(return_value, *ret, 1);
			*ret++;
		}
		g_free(ret);
	} else
		RETURN_NULL();
}
%%
ignore gtk_clist_new_with_titles
%%
override gtk_clist_new
PHP_FUNCTION(wrap_gtk_clist_new)
{
	GtkObject *wrapped_obj;
	gint columns, i;
	gchar **titles;
	zval *php_titles = NULL, **temp_title;
	HashTable *target_hash;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i|a/", &columns, &php_titles)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (columns <= 0) {
		php_error(E_WARNING, "%s() needs number of columns to be > 0", get_active_function_name());
		return;
	}

	if (php_titles) {
		if (zend_hash_num_elements(Z_ARRVAL_P(php_titles)) < columns) {
			php_error(E_WARNING, "%s(): the array of titles is not long enough", get_active_function_name());
			return;
		}

		target_hash = HASH_OF(php_titles);
		titles = emalloc(sizeof(gchar *) * columns);
		i = 0;
		zend_hash_internal_pointer_reset(target_hash);
		while (zend_hash_get_current_data(target_hash, (void **)&temp_title) == SUCCESS) {
			convert_to_string_ex(temp_title);
			titles[i++] = estrndup(Z_STRVAL_PP(temp_title), Z_STRLEN_PP(temp_title));
			zend_hash_move_forward(target_hash);
		}
		wrapped_obj = (GtkObject *)gtk_clist_new_with_titles(columns, titles);
		efree(titles);
	} else
		wrapped_obj = (GtkObject *)gtk_clist_new(columns);

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkCList object", get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);	
}
%%
override gtk_clist_append
PHP_FUNCTION(wrap_gtk_clist_append)
{
	gint columns, i, res;
	gchar **list;
	zval *php_list, **text;
	HashTable *target_hash;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a/", &php_list)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	columns = GTK_CLIST(PHP_GTK_GET(this_ptr))->columns;
	if (zend_hash_num_elements(Z_ARRVAL_P(php_list)) < columns) {
		php_error(E_WARNING, "%s(): the array of strings is not long enough", get_active_function_name());
		return;
	}
	
	target_hash = HASH_OF(php_list);
	list = emalloc(sizeof(gchar *) * columns);
	i = 0;
	zend_hash_internal_pointer_reset(target_hash);
	while (zend_hash_get_current_data(target_hash, (void **)&text) == SUCCESS) {
		convert_to_string_ex(text);
		list[i++] = estrndup(Z_STRVAL_PP(text), Z_STRLEN_PP(text));
		zend_hash_move_forward(target_hash);
	}
	ZVAL_LONG(return_value, gtk_clist_append(GTK_CLIST(PHP_GTK_GET(this_ptr)), list));
	efree(list);
}
%%
override gtk_clist_prepend
PHP_FUNCTION(wrap_gtk_clist_prepend)
{
	gint columns, i, res;
	gchar **list;
	zval *php_list, **text;
	HashTable *target_hash;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a/", &php_list)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	columns = GTK_CLIST(PHP_GTK_GET(this_ptr))->columns;
	if (zend_hash_num_elements(Z_ARRVAL_P(php_list)) < columns) {
		php_error(E_WARNING, "%s(): the array of strings is not long enough", get_active_function_name());
		return;
	}

	target_hash = HASH_OF(php_list);
	list = emalloc(sizeof(gchar *) * columns);
	i = 0;
	zend_hash_internal_pointer_reset(target_hash);
	while (zend_hash_get_current_data(target_hash, (void **)&text) == SUCCESS) {
		convert_to_string_ex(text);
		list[i++] = estrndup(Z_STRVAL_PP(text), Z_STRLEN_PP(text));
		zend_hash_move_forward(target_hash);
	}
	ZVAL_LONG(return_value, gtk_clist_prepend(GTK_CLIST(PHP_GTK_GET(this_ptr)), list));
	efree(list);
}
%%
override gtk_clist_insert
PHP_FUNCTION(wrap_gtk_clist_insert)
{
	gint columns, i, row, res;
	gchar **list;
	zval *php_list, **text;
	HashTable *target_hash;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ia/", &row, &php_list)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	columns = GTK_CLIST(PHP_GTK_GET(this_ptr))->columns;
	if (zend_hash_num_elements(Z_ARRVAL_P(php_list)) < columns) {
		php_error(E_WARNING, "%s(): the array of strings is not long enough", get_active_function_name());
		return;
	}

	target_hash = HASH_OF(php_list);
	list = emalloc(sizeof(gchar *) * columns);
	i = 0;
	zend_hash_internal_pointer_reset(target_hash);
	while (zend_hash_get_current_data(target_hash, (void **)&text) == SUCCESS) {
		convert_to_string_ex(text);
		list[i++] = estrndup(Z_STRVAL_PP(text), Z_STRLEN_PP(text));
		zend_hash_move_forward(target_hash);
	}
	ZVAL_LONG(return_value, gtk_clist_insert(GTK_CLIST(PHP_GTK_GET(this_ptr)), row, list));
	efree(list);
}
%%
override gtk_clist_get_text
PHP_FUNCTION(wrap_gtk_clist_get_text)
{
	gint row, column;
	gchar *text;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ii", &row, &column))
		return;

	if (!gtk_clist_get_text(GTK_CLIST(PHP_GTK_GET(this_ptr)), row, column, &text)) {
		php_error(E_WARNING, "%s() cannot get text value", get_active_function_name());
		return;
	}

	RETURN_STRING(text, 1);
}
%%
ignore gtk_menu_item_new_with_label 
%%
override gtk_menu_item_new
PHP_FUNCTION(wrap_gtk_menu_item_new)
{
	char *label;
	GtkObject *wrapped_obj;
	
	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &label)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (label)
		wrapped_obj = (GtkObject *)gtk_menu_item_new_with_label(label);		
	else
	    wrapped_obj = (GtkObject *)gtk_menu_item_new();

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkMenuItem object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}

%%
ignore gtk_check_menu_item_new_with_label 
%%
override gtk_check_menu_item_new
PHP_FUNCTION(wrap_gtk_check_menu_item_new)
{
	char *label;
	GtkObject *wrapped_obj;
	
	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &label)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (label)
		wrapped_obj = (GtkObject *)gtk_check_menu_item_new_with_label(label);		
	else
	    wrapped_obj = (GtkObject *)gtk_check_menu_item_new();

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkCheckMenuItem object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}
%%
override gtk_list_append_items
PHP_FUNCTION(wrap_gtk_list_append_items)
{
	zval *php_items, **item;
	GList *items = NULL;
	int i = 0;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &php_items))
		return;

	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(php_items));
		 zend_hash_get_current_data(Z_ARRVAL_P(php_items), (void **)&item) == SUCCESS;
		 zend_hash_move_forward(Z_ARRVAL_P(php_items)), i++) {
		if (!php_gtk_check_class(*item, gtk_listitem_ce)) {
			php_error(E_WARNING, "%s() needs list item #%d to be a GtkListItem", get_active_function_name(), i);
			g_list_free(items);
			return;
		}

		items = g_list_append(items, PHP_GTK_GET(*item));
	}

	gtk_list_append_items(GTK_LIST(PHP_GTK_GET(this_ptr)), items);
}
%%
ignore gtk_list_item_new_with_label
%%
override gtk_list_item_new
PHP_FUNCTION(wrap_gtk_list_item_new)
{
	GtkObject *wrapped_obj;
	gchar *text = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &text)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (text)
		wrapped_obj = (GtkObject *)gtk_list_item_new_with_label(text);
	else
		wrapped_obj = (GtkObject *)gtk_list_item_new();

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkListItem object",
				get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}
%%
ignore gtk_tree_item_new_with_label
%%
override gtk_tree_item_new
PHP_FUNCTION(wrap_gtk_tree_item_new)
{
	GtkObject *wrapped_obj;
	gchar *text = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &text)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (text)
		wrapped_obj = (GtkObject *)gtk_tree_item_new_with_label(text);
	else
		wrapped_obj = (GtkObject *)gtk_tree_item_new();

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkTreeItem object",
				get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}
%%
ignore gtk_button_new_with_label
%%
override gtk_button_new
PHP_FUNCTION(wrap_gtk_button_new)
{
	GtkObject *wrapped_obj;
	gchar *text = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &text)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (text)
		wrapped_obj = (GtkObject *)gtk_button_new_with_label(text);
	else
		wrapped_obj = (GtkObject *)gtk_button_new();

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkButton object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}
%%
ignore gtk_toggle_button_new_with_label
%%
override gtk_toggle_button_new
PHP_FUNCTION(wrap_gtk_toggle_button_new)
{
	GtkObject *wrapped_obj;
	gchar *text = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &text)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (text)
		wrapped_obj = (GtkObject *)gtk_toggle_button_new_with_label(text);
	else
		wrapped_obj = (GtkObject *)gtk_toggle_button_new();

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkToggleButton object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}
%%
ignore gtk_check_button_new_with_label
%%
override gtk_check_button_new
PHP_FUNCTION(wrap_gtk_check_button_new)
{
	char *label;
	GtkObject *wrapped_obj;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|s", &label)) {
		php_gtk_invalidate(this_ptr);
		return;
	}
	if (label)
    	wrapped_obj = (GtkObject *)gtk_check_button_new_with_label(label);
    else    
		wrapped_obj = (GtkObject *)gtk_check_button_new();
	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkCheckButton object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);
}
%%
ignore
  gtk_ctree_construct
  gtk_ctree_insert_gnode
  gtk_ctree_export_to_gnode
  gtk_ctree_post_recursive
  gtk_ctree_post_recursive_to_depth
  gtk_ctree_pre_recursive
  gtk_ctree_pre_recursive_to_depth
  gtk_ctree_find_node_ptr
  gtk_ctree_new
%%
override gtk_ctree_new_with_titles
PHP_FUNCTION(wrap_gtk_ctree_new_with_titles)
{
	GtkObject *wrapped_obj;
	gint columns, tree_column, i;
	gchar **titles;
	zval *php_titles = NULL, **temp_title;
	HashTable *target_hash;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ii|a/", &columns, &tree_column, &php_titles)) {
		php_gtk_invalidate(this_ptr);
		return;
	}

	if (columns <= 0) {
		php_error(E_WARNING, "%s() needs number of columns to be > 0", get_active_function_name());
		return;
	}

	if (php_titles) {
		if (zend_hash_num_elements(Z_ARRVAL_P(php_titles)) < columns) {
			php_error(E_WARNING, "%s(): the array of titles is not long enough", get_active_function_name());
			return;
		}

		target_hash = HASH_OF(php_titles);
		titles = emalloc(sizeof(gchar *) * columns);
		i = 0;
		zend_hash_internal_pointer_reset(target_hash);
		while (zend_hash_get_current_data(target_hash, (void **)&temp_title) == SUCCESS) {
			convert_to_string_ex(temp_title);
			titles[i++] = estrndup(Z_STRVAL_PP(temp_title), Z_STRLEN_PP(temp_title));
			zend_hash_move_forward(target_hash);
		}
		wrapped_obj = (GtkObject *)gtk_ctree_new_with_titles(columns, tree_column, titles);
		efree(titles);
	} else
		wrapped_obj = (GtkObject *)gtk_ctree_new(columns, tree_column);

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkCTree object", get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);	
}
%%
override gtk_ctree_insert_node
PHP_FUNCTION(wrap_gtk_ctree_insert_node)
{
	zval *php_parent, *php_sibling, *php_text,
		 *php_pixmap_closed, *php_pixmap_opened,
		 *php_mask_closed, *php_mask_opened, **temp_text;
	zval *php_ret;
	gint spacing, columns, i;
	zend_bool is_leaf, expanded;
	GtkCTreeNode *parent = NULL, *sibling = NULL, *ret;
	GdkPixmap *pixmap_closed = NULL, *pixmap_opened = NULL;
	GdkBitmap *mask_closed = NULL, *mask_opened = NULL;
	GtkCTree *tree;
	gchar **text = NULL;
	HashTable *target_hash;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "NNa/iNNNNbb", &php_parent,
							gtk_ctree_node_ce, &php_sibling, gtk_ctree_node_ce,
							&php_text, &spacing, &php_pixmap_closed,
							gdk_pixmap_ce, &php_mask_closed, gdk_bitmap_ce,
							&php_pixmap_opened, gdk_pixmap_ce, &php_mask_opened,
							gdk_bitmap_ce, &is_leaf, &expanded))
		return;

	target_hash = HASH_OF(php_text);
	tree = GTK_CTREE(PHP_GTK_GET(this_ptr));
	columns = GTK_CLIST(tree)->columns;
	if (zend_hash_num_elements(target_hash) < columns) {
		php_error(E_WARNING, "%s(): the text array is not long enough", get_active_function_name());
		return;
	}

	if (Z_TYPE_P(php_parent) != IS_NULL)
		parent			= PHP_GTK_CTREE_NODE_GET(php_parent);
	if (Z_TYPE_P(php_sibling) != IS_NULL)
		sibling			= PHP_GTK_CTREE_NODE_GET(php_sibling);
	if (Z_TYPE_P(php_pixmap_closed) != IS_NULL)
		pixmap_closed	= PHP_GDK_PIXMAP_GET(php_pixmap_closed);
	if (Z_TYPE_P(php_mask_closed) != IS_NULL)
		mask_closed		= PHP_GDK_BITMAP_GET(php_mask_closed);
	if (Z_TYPE_P(php_pixmap_opened) != IS_NULL)
		pixmap_opened	= PHP_GDK_PIXMAP_GET(php_pixmap_opened);
	if (Z_TYPE_P(php_mask_opened) != IS_NULL)
		mask_opened		= PHP_GDK_BITMAP_GET(php_mask_opened);

	text = emalloc(sizeof(gchar *) * columns);
	i = 0;
	zend_hash_internal_pointer_reset(target_hash);
	while (zend_hash_get_current_data(target_hash, (void **)&temp_text) == SUCCESS) {
		convert_to_string_ex(temp_text);
		text[i++] = estrndup(Z_STRVAL_PP(temp_text), Z_STRLEN_PP(temp_text));
		zend_hash_move_forward(target_hash);
	}

	ret = gtk_ctree_insert_node(tree, parent, sibling, text, (guint8)spacing,
								pixmap_closed, mask_closed, pixmap_opened,
								mask_opened, is_leaf, expanded);
	efree(text);
	php_ret = php_gtk_ctree_node_new(ret);
	SEPARATE_ZVAL(&php_ret);
	*return_value = *php_ret;
}
%%
override gtk_ctree_post_recursive
static void ctree_callback(GtkCTree *ctree, GtkCTreeNode *node, zval *callback_data)
{
	zval *retval = NULL;
	zval **callback = NULL, **extra = NULL;
	zval **callback_filename = NULL, **callback_lineno = NULL;
	zval ***args, *params;
	char *callback_name;
	ELS_FETCH();

	zend_hash_index_find(Z_ARRVAL_P(callback_data), 0, (void **)&callback);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 1, (void **)&extra);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 2, (void **)&callback_filename);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 3, (void **)&callback_lineno);

	if (!php_gtk_is_callable(*callback, 0, &callback_name)) {
		php_error(E_WARNING, "Unable to call ctree callback '%s' specified in %s on line %d", callback_name, Z_STRVAL_PP(callback_filename), Z_LVAL_PP(callback_lineno));
		efree(callback_name);
		return;
	}

	params = php_gtk_build_value("(NN)", php_gtk_new((GtkObject *)ctree),
								 php_gtk_ctree_node_new(node));
	if (extra)
		php_array_merge(Z_ARRVAL_P(params), Z_ARRVAL_PP(extra), 0);

	args = php_gtk_hash_as_array(params);

	call_user_function_ex(EG(function_table), NULL, *callback, &retval, zend_hash_num_elements(Z_ARRVAL_P(params)), args, 1, NULL);
	if (retval)
		zval_ptr_dtor(&retval);
	efree(args);
	zval_ptr_dtor(&params);
}

static void traverse_ctree(INTERNAL_FUNCTION_PARAMETERS, zend_bool use_depth, zend_bool pre_order)
{
	zval *ctree, *php_node, *callback;
	zval *data, *extra;
	GtkCTreeNode *node = NULL;
	gint depth;
	int req_args = 2;
	char *callback_filename;
	uint callback_lineno;

	NOT_STATIC_METHOD();

	if (use_depth)
		req_args = 3;

	if (ZEND_NUM_ARGS() < req_args) {
		php_error(E_WARNING, "%s() requires at least %d arguments, %d given",
				  get_active_function_name(), req_args, ZEND_NUM_ARGS());
		return;
	}

	if (use_depth) {
		if (!php_gtk_parse_args(3, "NiV", &php_node, gtk_ctree_node_ce, &depth, &callback))
			return;
	} else {
		if (!php_gtk_parse_args(2, "NV", &php_node, gtk_ctree_node_ce, &callback))
			return;
	}

	if (Z_TYPE_P(php_node) != IS_NULL)
		node = PHP_GTK_CTREE_NODE_GET(php_node);

	callback_filename = zend_get_executed_filename(ELS_C);
	callback_lineno = zend_get_executed_lineno(ELS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 2, ZEND_NUM_ARGS());
	data = php_gtk_build_value("(VNsi)", callback, extra, callback_filename, callback_lineno);
	if (pre_order) {
		if (use_depth)
			gtk_ctree_pre_recursive_to_depth(GTK_CTREE(PHP_GTK_GET(this_ptr)),
											 node, depth,
											 (GtkCTreeFunc)ctree_callback, data);
		else
			gtk_ctree_pre_recursive(GTK_CTREE(PHP_GTK_GET(this_ptr)), node,
									(GtkCTreeFunc)ctree_callback, data);
	} else {
		if (use_depth)
			gtk_ctree_post_recursive_to_depth(GTK_CTREE(PHP_GTK_GET(this_ptr)),
											  node, depth,
											  (GtkCTreeFunc)ctree_callback, data);
		else
			gtk_ctree_post_recursive(GTK_CTREE(PHP_GTK_GET(this_ptr)), node,
									 (GtkCTreeFunc)ctree_callback, data);
	}
}

PHP_FUNCTION(wrap_gtk_ctree_post_recursive)
{
	traverse_ctree(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}
%%
override gtk_ctree_post_recursive_to_depth
PHP_FUNCTION(wrap_gtk_ctree_post_recursive_to_depth)
{
	traverse_ctree(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 0);
}
%%
override gtk_ctree_pre_recursive
PHP_FUNCTION(wrap_gtk_ctree_pre_recursive)
{
	traverse_ctree(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);
}
%%
override gtk_ctree_pre_recursive_to_depth
PHP_FUNCTION(wrap_gtk_ctree_pre_recursive_to_depth)
{
	traverse_ctree(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 1);
}
%%
override gtk_container_children
PHP_FUNCTION(wrap_gtk_container_children)
{
	GList *children, *tmp;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	children = gtk_container_children(GTK_CONTAINER(PHP_GTK_GET(this_ptr)));
	array_init(return_value);
	for (tmp = children; tmp; tmp = tmp->next)
		add_next_index_zval(return_value, php_gtk_new(tmp->data));
	g_list_free(children);
}
%%
override gtk_item_factory_create_items
static void item_factory_callback(zval *callback_data, guint action, GtkWidget *widget)
{
	zval *retval = NULL;
	zval **callback, **extra;
	zval **callback_filename, **callback_lineno;
	zval *params;
	zval ***args;
	char *callback_name;
	ELS_FETCH();

	zend_hash_index_find(Z_ARRVAL_P(callback_data), 0, (void **)&callback);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 1, (void **)&callback_filename);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 2, (void **)&callback_lineno);
	if (!php_gtk_is_callable(*callback, 0, &callback_name)) {
		php_error(E_WARNING, "unable to call item factory callback '%s' specified in %s on line %d", callback_name, Z_STRVAL_PP(callback_filename), Z_LVAL_PP(callback_lineno));
		efree(callback_name);
		return;
	}

	params = php_gtk_build_value("(iN)", action, php_gtk_new((GtkObject *)widget));
	if (zend_hash_num_elements(Z_ARRVAL_P(callback_data)) > 3) {
		zend_hash_index_find(Z_ARRVAL_P(callback_data), 3, (void **)&extra);
		php_array_merge(Z_ARRVAL_P(params), Z_ARRVAL_PP(extra), 0);
	}

	args = php_gtk_hash_as_array(params);

	call_user_function_ex(EG(function_table), NULL, *callback, &retval, zend_hash_num_elements(Z_ARRVAL_P(params)), args, 1, NULL);
	if (retval)
		zval_ptr_dtor(&retval);
	efree(args);
	zval_ptr_dtor(&params);
}

PHP_FUNCTION(wrap_gtk_item_factory_create_items)
{
	zval *list, **item, *callback_data,
		 *callback, *extra = NULL;
	GtkItemFactoryEntry entry;
	GtkItemFactory *factory;
	int i = 0;
	char *callback_filename;
	uint callback_lineno;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &list))
		return;
	
	factory = GTK_ITEM_FACTORY(PHP_GTK_GET(this_ptr));
	zend_hash_internal_pointer_reset(Z_ARRVAL_P(list));
	while (zend_hash_get_current_data(Z_ARRVAL_P(list), (void**)&item) == SUCCESS) {
		if (Z_TYPE_PP(item) != IS_ARRAY ||
			!php_gtk_parse_args_hash_quiet(*item, "ssVis|a", &entry.path,
									 &entry.accelerator, &callback,
									 &entry.callback_action, &entry.item_type, &extra)) {
			php_error(E_WARNING, "%s() was unable to parse item #%d in the input array",
					  get_active_function_name(), i+1);
			return;
		}

		if (Z_TYPE_P(callback) == IS_NULL)
			entry.callback = NULL;
		else {
			callback_filename = zend_get_executed_filename(ELS_C);
			callback_lineno = zend_get_executed_lineno(ELS_C);
			if (extra)
				callback_data = php_gtk_build_value("(VsiV)", callback, callback_filename, callback_lineno, extra);
			else
				callback_data = php_gtk_build_value("(Vsi)", callback, callback_filename, callback_lineno);
			entry.callback = (GtkItemFactoryCallback)item_factory_callback;
		}

		gtk_item_factory_create_item(factory, &entry, callback_data, 1);

		i++;
		zend_hash_move_forward(Z_ARRVAL_P(list));
	}

	RETURN_TRUE;
}
%%
override gtk_combo_set_popdown_strings
PHP_FUNCTION(wrap_gtk_combo_set_popdown_strings)
{
	zval *php_list, **item;
	GList *list = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a/", &php_list))
		return;

	zend_hash_internal_pointer_reset(Z_ARRVAL_P(php_list));
	while (zend_hash_get_current_data(Z_ARRVAL_P(php_list), (void **)&item) == SUCCESS) {
		convert_to_string_ex(item);
		list = g_list_append(list, Z_STRVAL_PP(item));
		zend_hash_move_forward(Z_ARRVAL_P(php_list));
	}

	gtk_combo_set_popdown_strings(GTK_COMBO(PHP_GTK_GET(this_ptr)), list);
	g_list_free(list);
	RETURN_TRUE;
}
%%
override gtk_label_get
PHP_FUNCTION(wrap_gtk_label_get)
{
	gchar *text;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	gtk_label_get(GTK_LABEL(PHP_GTK_GET(this_ptr)), &text);
	RETURN_STRING(text, 1);
}
%%
getprop GtkBox children
	GList *tmp;
	GList *children = GTK_BOX(PHP_GTK_GET(object))->children;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = children, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					*return_value = *php_gtk_box_child_new((GtkBoxChild *)tmp->data);
					return;
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = children; tmp; tmp = tmp->next) {
			add_next_index_zval(return_value, php_gtk_box_child_new((GtkBoxChild *)tmp->data));
		}
	}
%%
getprop GtkCalendar marked_date
	GtkCalendar *cal = GTK_CALENDAR(PHP_GTK_GET(object));
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			if (prop_index > 0 && prop_index < 31)
				ZVAL_LONG(return_value, cal->marked_date[prop_index]);
		}
	} else {
		int i;

		array_init(return_value);
		for (i = 0; i < 31; i++)
			add_next_index_long(return_value, cal->marked_date[i]);
	}
%%
override gtk_calendar_get_date
PHP_FUNCTION(wrap_gtk_calendar_get_date)
{
	guint year, month, day;

	NOT_STATIC_METHOD();

	gtk_calendar_get_date(GTK_CALENDAR(PHP_GTK_GET(this_ptr)), &year, &month, &day);
	*return_value = *php_gtk_build_value("(iii)", year, month, day);
}
%%
getprop GtkFixed children
	GList *tmp;
	GList *children = GTK_FIXED(PHP_GTK_GET(object))->children;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = children, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					*return_value = *php_gtk_fixed_child_new((GtkFixedChild *)tmp->data);
					return;
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = children; tmp; tmp = tmp->next) {
			add_next_index_zval(return_value, php_gtk_fixed_child_new((GtkFixedChild *)tmp->data));
		}
	}
%%
getprop GtkList selection
	GtkListItem *item;
	GList *tmp;
	GList *selection = GTK_LIST(PHP_GTK_GET(object))->selection;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = selection, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					*return_value = *php_gtk_new((GtkObject *)tmp->data);
					return;
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = selection; tmp; tmp = tmp->next)
			add_next_index_zval(return_value, php_gtk_new((GtkObject *)tmp->data));
	}
%%
getprop GtkCList selection
	GList *tmp;
	GList *selection = GTK_CLIST(PHP_GTK_GET(object))->selection;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = selection, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					RETURN_LONG(GPOINTER_TO_INT(tmp->data));
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = selection; tmp; tmp = tmp->next)
			add_next_index_long(return_value, GPOINTER_TO_INT(tmp->data));
	}
%%
getprop GtkCTree selection
	GList *tmp;
	GList *selection = GTK_CLIST(PHP_GTK_GET(object))->selection;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = selection, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					*return_value = *php_gtk_ctree_node_new(GTK_CTREE_NODE(tmp->data));
					return;
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = selection; tmp; tmp = tmp->next)
			add_next_index_zval(return_value, php_gtk_ctree_node_new(GTK_CTREE_NODE(tmp->data)));
	}
%%
ignore gtk_radio_menu_item_new_with_label
%%
override gtk_radio_menu_item_new
PHP_FUNCTION(wrap_gtk_radio_menu_item_new)
{
	zval *php_group = NULL;
	gchar *text = NULL;
	GtkRadioMenuItem *group = NULL;
	GtkObject *wrapped_obj = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Ns", &php_group, gtk_radiomenuitem_ce, &text))
		return;

	if (Z_TYPE_P(php_group) != IS_NULL)
		group = GTK_RADIO_MENU_ITEM(PHP_GTK_GET(php_group));

	if (!text) {
		if (!group)
			wrapped_obj = (GtkObject *)gtk_radio_menu_item_new(NULL);
		else
			wrapped_obj = (GtkObject *)gtk_radio_menu_item_new(group->group);
	} else {
		if (!group)
			wrapped_obj = (GtkObject *)gtk_radio_menu_item_new_with_label(NULL, text);
		else
			wrapped_obj = (GtkObject *)gtk_radio_menu_item_new_with_label(group->group, text);
	}

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkRadioMenuItem object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);	
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new
PHP_FUNCTION(wrap_gtk_radio_button_new)
{
	zval *php_group = NULL;
	gchar *text = NULL;
	GtkRadioButton *group = NULL;
	GtkObject *wrapped_obj = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Ns", &php_group, gtk_radiobutton_ce, &text))
		return;

	if (Z_TYPE_P(php_group) != IS_NULL)
		group = GTK_RADIO_BUTTON(PHP_GTK_GET(php_group));

	if (!text) {
		if (!group)
			wrapped_obj = (GtkObject *)gtk_radio_button_new(NULL);
		else
			wrapped_obj = (GtkObject *)gtk_radio_button_new(group->group);
	} else {
		if (!group)
			wrapped_obj = (GtkObject *)gtk_radio_button_new_with_label(NULL, text);
		else
			wrapped_obj = (GtkObject *)gtk_radio_button_new_with_label(group->group, text);
	}

	if (!wrapped_obj) {
		php_error(E_WARNING, "%s(): could not create GtkRadioButton object",
				  get_active_function_name());
		php_gtk_invalidate(this_ptr);
		return;
	}

	php_gtk_object_init(wrapped_obj, this_ptr);	
}
%%
override gtk_color_selection_set_color
PHP_FUNCTION(wrap_gtk_color_selection_set_color)
{
	gdouble value[4];

	NOT_STATIC_METHOD();

	value[3] = 1.0;
	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ddd|d",
							&value[0], &value[1], &value[2], &value[3]))
		return;

	gtk_color_selection_set_color(GTK_COLOR_SELECTION(PHP_GTK_GET(this_ptr)), value);
}
%%
override gtk_color_selection_get_color
PHP_FUNCTION(wrap_gtk_color_selection_get_color)
{
	gdouble value[4];
	GtkColorSelection *colorsel;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	colorsel = GTK_COLOR_SELECTION(PHP_GTK_GET(this_ptr));
	gtk_color_selection_get_color(colorsel, value);
	if (colorsel->use_opacity)
		*return_value = *php_gtk_build_value("(dddd)", value[0], value[1], value[2], value[3]);
	else
		*return_value = *php_gtk_build_value("(ddd)", value[0], value[1], value[2]);
}
%%
getprop GtkCTree clist
	*return_value = *php_gtk_new((GtkObject *)GTK_CLIST(PHP_GTK_GET(object)));
%%
getprop GtkCList row_list
	GList *tmp;
	GList *row_list = GTK_CLIST(PHP_GTK_GET(object))->row_list;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = row_list, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					*return_value = *php_gtk_clist_row_new((GtkCListRow *)tmp->data);
					return;
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = row_list; tmp; tmp = tmp->next) {
			add_next_index_zval(return_value, php_gtk_clist_row_new((GtkCListRow *)tmp->data));
		}
	}
%%
getprop GtkCTree row_list
	GList *tmp;
	GList *row_list = GTK_CLIST(PHP_GTK_GET(object))->row_list;
	zend_overloaded_element *property;
	zend_llist_element *next = (*element)->next;
	int prop_index;

	if (next) {
		int i = 0;
		property = (zend_overloaded_element *)next->data;
		if (Z_TYPE_P(property) == OE_IS_ARRAY && Z_TYPE(property->element) == IS_LONG) {
			*element = next;
			prop_index = Z_LVAL(property->element);
			for (tmp = row_list, i = 0; tmp; tmp = tmp->next, i++) {
				if (i == prop_index) {
					*return_value = *php_gtk_ctree_node_new(GTK_CTREE_NODE(tmp));
					return;
				}
			}
		}
	} else {
		array_init(return_value);
		for (tmp = row_list; tmp; tmp = tmp->next) {
			add_next_index_zval(return_value, php_gtk_ctree_node_new(GTK_CTREE_NODE(tmp)));
		}
	}
%%
ignore gtk_ctree_node_set_row_data_full
%%
override gtk_ctree_node_set_row_data kwargs
PHP_FUNCTION(wrap_gtk_ctree_node_set_row_data)
{
	zval *node, *data;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "OV", &node, gtk_ctree_node_ce, &data))
		return;

	zval_add_ref(&data);
	gtk_ctree_node_set_row_data_full(GTK_CTREE(PHP_GTK_GET(this_ptr)),
									 PHP_GTK_CTREE_NODE_GET(node), data,
									 php_gtk_destroy_notify);
}
%%
override gtk_ctree_node_get_row_data
PHP_FUNCTION(wrap_gtk_ctree_node_get_row_data)
{
	zval *node, *data;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "O", &node, gtk_ctree_node_ce))
		return;

	data = gtk_ctree_node_get_row_data(GTK_CTREE(PHP_GTK_GET(this_ptr)),
									   PHP_GTK_CTREE_NODE_GET(node));
	if (data) {
		*return_value = *data;
		zval_copy_ctor(return_value);
	} else {
		RETURN_NULL();
	}
}
%%
override gtk_ctree_node_get_text
PHP_FUNCTION(wrap_gtk_ctree_node_get_text)
{
	zval *node;
	gint column;
	gchar *text = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Oi", &node, gtk_ctree_node_ce, &column))
		return;

	if (!gtk_ctree_node_get_text(GTK_CTREE(PHP_GTK_GET(this_ptr)),
								 PHP_GTK_CTREE_NODE_GET(node), column, &text)) {
		php_error(E_WARNING, "%s() cannot get text value", get_active_function_name());
		return;
	}

	RETURN_STRING(text, 1);
}
%%
override gtk_menu_popup
static void php_gtk_menu_position(GtkMenu *menu, int *x, int *y, zval *callback_data)
{
	zval **callback, *php_menu;
	zval **callback_filename, **callback_lineno;
	zval *retval, *params;
	zval ***args;
	char *callback_name;
	ELS_FETCH();

	zend_hash_index_find(Z_ARRVAL_P(callback_data), 0, (void **)&callback);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 1, (void **)&callback_filename);
	zend_hash_index_find(Z_ARRVAL_P(callback_data), 2, (void **)&callback_lineno);
	if (!php_gtk_is_callable(*callback, 0, &callback_name)) {
		php_error(E_WARNING, "unable to call menu position callback '%s' specified in %s on line %d", callback_name, Z_STRVAL_PP(callback_filename), Z_LVAL_PP(callback_lineno));
		efree(callback_name);
		return;
	}

	params = php_gtk_build_value("(Nii)", php_gtk_new(GTK_OBJECT(menu)), *x, *y);
	args = php_gtk_hash_as_array(params);

	call_user_function_ex(EG(function_table), NULL, *callback, &retval, zend_hash_num_elements(Z_ARRVAL_P(params)), args, 1, NULL);

	if (retval) {
		if (Z_TYPE_P(retval) == IS_ARRAY &&
			!php_gtk_parse_args_hash_quiet(retval, "ii", x, y)) {
			php_error(E_WARNING, "unable to parse result of menu position callback");
		}
		zval_ptr_dtor(&retval);
	}

	efree(args);
	zval_ptr_dtor(&params);
}

PHP_FUNCTION(wrap_gtk_menu_popup)
{
	zval *php_pms, *php_pmi;
	GtkWidget *pms = NULL, *pmi = NULL;
	zval *callback, *data;
	int button, time;
	char *callback_filename;
	uint callback_lineno;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "NNVii", &php_pms, gtk_widget_ce,
							&php_pmi, gtk_widget_ce, &callback, &button, &time))
		return;

	if (Z_TYPE_P(php_pms) != IS_NULL)
		pms = GTK_WIDGET(PHP_GTK_GET(php_pms));
	if (Z_TYPE_P(php_pmi) != IS_NULL)
		pmi = GTK_WIDGET(PHP_GTK_GET(php_pmi));

	if (Z_TYPE_P(callback) != IS_NULL) {
		callback_filename = zend_get_executed_filename(ELS_C);
		callback_lineno = zend_get_executed_lineno(ELS_C);
		data = php_gtk_build_value("(Vsi)", callback, callback_filename, callback_lineno);
		gtk_menu_popup(GTK_MENU(PHP_GTK_GET(this_ptr)), pms, pmi,
					   (GtkMenuPositionFunc)php_gtk_menu_position, data,
					   button, time);
	} else
		gtk_menu_popup(GTK_MENU(PHP_GTK_GET(this_ptr)), pms, pmi, NULL, NULL,
					   button, time);
}
%%
override gtk_editable_insert_text
PHP_FUNCTION(wrap_gtk_editable_insert_text)
{
	char *text;
	int len, pos;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s#i", &text, &len, &pos))
		return;

	gtk_editable_insert_text(GTK_EDITABLE(PHP_GTK_GET(this_ptr)), text, len, &pos);
	RETURN_LONG(pos);
}
