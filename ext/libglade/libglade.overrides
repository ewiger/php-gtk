/* vim: set ft=cpp: */
%%
headers
#include <glade/glade.h>
#include "php_gtk_api.h"
%%
ignore-glob
  *_get_type
%%
ignore
  glade_xml_construct
  glade_xml_signal_connect_data
  glade_xml_signal_connect_full
  glade_xml_signal_autoconnect_full

%% {{{ GladeXML
%%
override glade_xml_new
PHP_METHOD
{
    char *fname, *root = NULL, *domain = NULL;
    zend_bool free_fname, free_root, free_domain;
    GObject *wrapped_obj;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u|uu", &fname, &free_fname, &root, &free_root, &domain, &free_domain)) {
        return;
    }

    wrapped_obj = (GObject *) glade_xml_new(fname, (const char *)root, (const char *)domain);
    if (free_fname) g_free(fname);
    if (free_root) g_free(root);
    if (free_domain) g_free(domain);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GladeXML);
    }
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override glade_xml_get_widget_prefix
PHP_METHOD
{
    char *name;
    zend_bool free_name;
    GList *list, *item;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u", &name, &free_name)) {
        return;
    }

    list = glade_xml_get_widget_prefix(GLADE_XML(PHPG_GOBJECT(this_ptr)), (const char *)name);
    if (free_name) g_free(name);

    array_init(return_value);
    for (item = list; item; item = item->next) {
        zval *php_item = NULL;
        phpg_gobject_new(&php_item, G_OBJECT(item->data) TSRMLS_CC);
        add_next_index_zval(return_value, php_item);
    }

    g_list_free(list);
}

%% }}}
