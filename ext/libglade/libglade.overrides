/* vim: set ft=cpp: */
%%
headers
#include <glade/glade.h>
#include "php_gtk_api.h"

%% {{{ ignores [confirmed]
%%
ignore-glob
  *_get_type
%%
ignore
  glade_xml_construct
  glade_xml_signal_autoconnect_full
  glade_xml_signal_connect_data
  glade_xml_signal_connect_full
%% }}}

%% {{{ ignores [tbd]
%%
ignore
  glade_set_custom_handler
%% }}}

%% {{{ GladeXML
%%
override glade_xml_new
PHP_METHOD
{
    char *fname, *root = NULL, *domain = NULL;
    zend_bool free_fname, free_root, free_domain;
    GObject *wrapped_obj;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u|uu", &fname, &free_fname, &root, &free_root, &domain, &free_domain)) {
        return;
    }

    wrapped_obj = (GObject *) glade_xml_new(fname, (const char *)root, (const char *)domain);

    if (free_fname) g_free(fname);
    if (free_root) g_free(root);
    if (free_domain) g_free(domain);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GladeXML);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override glade_xml_new_from_buffer
PHP_METHOD
{
    char *buf, *root = NULL, *domain = NULL;
    zend_bool free_buf, free_root, free_domain;
    GladeXML *glade_obj;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u|uu", &buf, &free_buf, &root, &free_root, &domain, &free_domain)) {
        return;
    }

    glade_obj = glade_xml_new_from_buffer(buf, strlen(buf), (const char *)root, (const char *)domain);

    if (free_buf) g_free(buf);
    if (free_root) g_free(root);
    if (free_domain) g_free(domain);

    phpg_gobject_new(&return_value, (GObject *)glade_obj TSRMLS_CC);
}

%%
override glade_xml_get_widget_prefix
PHP_METHOD
{
    char *name;
    zend_bool free_name;
    GList *list, *item;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u", &name, &free_name)) {
        return;
    }

    list = glade_xml_get_widget_prefix(GLADE_XML(PHPG_GOBJECT(this_ptr)), (const char *)name);
    if (free_name) g_free(name);

    array_init(return_value);
    for (item = list; item; item = item->next) {
        zval *php_item = NULL;
        phpg_gobject_new(&php_item, G_OBJECT(item->data) TSRMLS_CC);
        add_next_index_zval(return_value, php_item);
    }

    g_list_free(list);
}

%%
override glade_xml_signal_connect
static void glade_signal_marshal(const gchar *handler_name, GObject *object,
                               const gchar *signal_name, const gchar *signal_data,
                               GObject *connect_object, gboolean after,
                               gpointer *data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *)data;
    char *callback_name;
    int handler_id, n_args = 0;
    GClosure *closure = NULL;
    zval *php_object = NULL, *php_connect_object = NULL;
    zval *hash = NULL, ***args = NULL;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "unable to call GladeXML callback '%s' specified in %s on line %ld\n",
                callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return;
    }

    if (connect_object) {
        phpg_gobject_new(&php_connect_object, (GObject*)connect_object TSRMLS_CC);
        args = php_gtk_hash_as_array_offset(cbd->user_args, 1, &n_args);
        args[0] = &php_connect_object;
        hash = php_gtk_array_as_hash(args, n_args, 0, n_args);
        closure = phpg_closure_new(cbd->callback, hash, PHPG_CONNECT_OBJECT TSRMLS_CC);
        efree(args);
    } else {
        closure = phpg_closure_new(cbd->callback, cbd->user_args, PHPG_CONNECT_NORMAL TSRMLS_CC);
    }

    phpg_gobject_new(&php_object, (GObject*)object TSRMLS_CC);
    phpg_gobject_watch_closure(php_object, closure TSRMLS_CC);
    handler_id = g_signal_connect_closure(object, signal_name, closure, after);

    efree(callback_name);
}

PHP_METHOD(glade_xml_signal_connect)
{
    char *handlername = NULL;
    zval *callback = NULL, *extra = NULL;
    zend_bool free_handlername;
    phpg_cb_data_t *data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 2, &extra, "uV", &handlername, &free_handlername, &callback))
        return;

    zval_add_ref(&callback);
    data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    glade_xml_signal_connect_full(GLADE_XML(PHPG_GOBJECT(this_ptr)), handlername, 
                                  (GladeXMLConnectFunc)glade_signal_marshal, data);

    if (free_handlername) g_free(handlername);

    RETURN_NULL();
}

%%
override glade_xml_signal_autoconnect
static void glade_auto_signal_marshal(const gchar *handler_name, GObject *object,
                               const gchar *signal_name, const gchar *signal_data,
                               GObject *connect_object, gboolean after,
                               zval *data)
{
    zval *callback = NULL, *hash = NULL, ***args = NULL;
    zval *php_object = NULL, *php_connect_object = NULL;
    GClosure *closure = NULL;
    int handler_id, n_args = 0, len = 0, gtk_flag = 0;
    char *php_class = NULL, *php_method = NULL;
    TSRMLS_FETCH();

    MAKE_STD_ZVAL(callback);

    if (strstr(handler_name, "::")) {
        len = strcspn(handler_name, ":");
        php_class = safe_estrndup(handler_name, len);
        php_method = strstr(handler_name, "::") + 2;
        array_init(callback);
        add_next_index_string(callback, php_class, 1);
        add_next_index_string(callback, php_method, 1);

        if (strcmp(php_class, "gtk") == 0 || strcmp(php_class, "gdk") == 0) {
            gtk_flag = 1;
        }

        efree(php_class);
    } else {
        ZVAL_STRING(callback, (char *)handler_name, 1);
    }

    if (!zend_is_callable(callback, 0, NULL)) {
        php_error(E_WARNING, "%s() is unable to autoconnect callback for handler '%s'",
              get_active_function_name(TSRMLS_C), handler_name);
        return;
    }

    if (connect_object || gtk_flag) {
        if (connect_object) {
            phpg_gobject_new(&php_connect_object, (GObject*)connect_object TSRMLS_CC);
            args = php_gtk_hash_as_array_offset(data, 1, &n_args);
            args[0] = &php_connect_object;
            hash = php_gtk_array_as_hash(args, n_args, 0, n_args);
            efree(args);
        }
        closure = phpg_closure_new(callback, hash, PHPG_CONNECT_OBJECT TSRMLS_CC);
    } else {
        closure = phpg_closure_new(callback, data, PHPG_CONNECT_NORMAL TSRMLS_CC);
    }

    phpg_gobject_new(&php_object, (GObject*)object TSRMLS_CC);
    phpg_gobject_watch_closure(php_object, closure TSRMLS_CC);
    handler_id = g_signal_connect_closure(object, signal_name, closure, after);
}

PHP_METHOD(glade_xml_signal_autoconnect)
{
    zval *extra = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 0, &extra, ""))
        return;

    glade_xml_signal_autoconnect_full(GLADE_XML(PHPG_GOBJECT(this_ptr)),
                             (GladeXMLConnectFunc)glade_auto_signal_marshal, extra);
}

%% }}}
