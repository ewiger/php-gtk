/* vim: set et ft=cpp fdm=marker: */
%%
headers
#include "php_gtk_api.h"
#include "ext/standard/file.h"

#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

/* TODO
 * implement gtk_adjustment_set_all
 */
%% {{{ ignores [confirmed]

%%
ignore-glob
    *_ref
    *_unref
    *_get_type
    gtk_arg_*
    gtk_args_*
    gtk_check_button_new_*
    gtk_init_add_*
    gtk_marshal_*
    gtk_quit_add_*
    gtk_radio_button_new_*
    gtk_radio_tool_button_new_*
    gtk_signal_*
    gtk_timeout_add_*
    gtk_toggle_button_new_*
%%
ignore-win32-glob
    gtk_plug_*
    gtk_socket_*
%%
ignore
    gtk_button_new_with_label
    gtk_button_new_with_mnemonic
    gtk_color_button_new
    gtk_dialog_new
    gtk_exit
    gtk_entry_new_with_max_length
    gtk_false
    gtk_icon_view_new_with_model
    gtk_image_menu_item_new_from_stock
    gtk_image_menu_item_new_with_label
    gtk_image_menu_item_new_with_mnemonic
    gtk_init
    gtk_init_check
    gtk_menu_item_new_with_label
    gtk_menu_item_new_with_mnemonic
    gtk_radio_menu_item_new_with_label
    gtk_radio_menu_item_new_with_mnemonic
    gtk_true
%%
ignore-win32
    GtkPlug
    GtkSocket
%% }}}
    
%% {{{ ignores [tbd]
%%
ignore-glob
    gtk_idle_add_*
    gtk_target_list_*
%%
ignore
    gtk_accel_group_activate
    gtk_accel_group_add
    gtk_accel_group_attach
    gtk_accel_group_create_add
    gtk_accel_group_create_remove
    gtk_accel_group_detach
    gtk_accel_group_entries_from_object
    gtk_accel_group_get_entry
    gtk_accel_group_handle_add
    gtk_accel_group_handle_remove
    gtk_accel_group_lock
    gtk_accel_group_lock_entry
    gtk_accel_group_new
    gtk_accel_group_ref
    gtk_accel_group_remove
    gtk_accel_groups_activate
    gtk_accel_groups_from_object
    gtk_accel_group_unlock
    gtk_accel_group_unlock_entry
    gtk_accel_group_unref
    gtk_adjustment_set_all
    gtk_clist_construct
    gtk_clist_set_row_data_full
    gtk_draw_box_gap
    gtk_draw_check
    gtk_draw_cross
    gtk_draw_extension
    gtk_draw_flat_box
    gtk_draw_focus
    gtk_draw_handle
    gtk_draw_option
    gtk_draw_ramp
    gtk_draw_shadow_gap
    gtk_draw_slider
    gtk_draw_tab
    gtk_file_chooser_dialog_new
    gtk_idle_remove_by_data
    gtk_item_factory_create_item
    gtk_item_factory_create_items_ac
    gtk_item_factory_create_menu_entries
    gtk_item_factory_delete_entries
    gtk_item_factory_delete_entry
    gtk_item_factory_popup_data
    gtk_item_factory_popup_with_data
    gtk_item_factory_set_translate_func
    gtk_key_snooper_install
    gtk_key_snooper_remove
    gtk_label_new_with_mnemonic
    gtk_menu_attach_to_widget
    gtk_message_dialog_new_with_markup
    gtk_object_add_arg_type
    gtk_object_arg_get
    gtk_object_arg_get_info
    gtk_object_args_collect
    gtk_object_arg_set
    gtk_object_get
    gtk_object_get_data_by_id
    gtk_object_get_user_data
    gtk_object_getv
    gtk_object_new
    gtk_object_newv
    gtk_object_query_args
    gtk_object_remove_data_by_id
    gtk_object_remove_no_notify_by_id
    gtk_object_set
    gtk_object_set_data_by_id
    gtk_object_set_data_by_id_full
    gtk_object_set_data_full
    gtk_object_set_user_data
    gtk_object_setv
    gtk_object_weakref
    gtk_object_weakunref
    gtk_preview_uninit
    gtk_progress_bar_new
    gtk_progress_bar_update
    gtk_propagate_event
    gtk_quit_remove_by_data
    gtk_range_default_htrough_click
    gtk_range_default_vtrough_click
    gtk_range_trough_click
    gtk_set_locale
    gtk_signal_add_emission_hook_full
    gtk_signal_disconnect_by_data
    gtk_signal_disconnect_by_func
    gtk_signal_emit
    gtk_signal_emit_by_name
    gtk_signal_emitv
    gtk_signal_emitv_by_name
    gtk_signal_handler_block_by_data
    gtk_signal_handler_block_by_func
    gtk_signal_handler_pending_by_func
    gtk_signal_handler_unblock_by_data
    gtk_signal_handler_unblock_by_func
    gtk_signal_n_emissions
    gtk_signal_n_emissions_by_name
    gtk_signal_query
    gtk_signal_set_funcs
    gtk_tooltips_data_get
    gtk_trace_referencing
    gtk_type_check_class_cast
    gtk_type_check_object_cast
    gtk_type_register_enum
    gtk_type_register_flags
    gtk_widget_get
    gtk_widget_getv
    gtk_widget_new
    gtk_widget_newv
    gtk_widget_reset_shapes
    gtk_widget_set
    gtk_widget_setv
    gtk_window_add_embedded_xid
    gtk_window_remove_embedded_xid
    gtk_window_reposition
%%
ignore
    GtkArgFlags
    GtkPrivateFlags
%% }}}

%% {{{ constants
%%
constants
    /* register non-enum constants */

    phpg_register_int_constant(gtk_ce, "PRIORITY_HIGH", sizeof("PRIORITY_HIGH")-1, G_PRIORITY_HIGH);
    phpg_register_int_constant(gtk_ce, "PRIORITY_DEFAULT", sizeof("PRIORITY_DEFAULT")-1, G_PRIORITY_DEFAULT);
    phpg_register_int_constant(gtk_ce, "PRIORITY_HIGH_IDLE", sizeof("PRIORITY_HIGH_IDLE")-1, G_PRIORITY_HIGH_IDLE);
    phpg_register_int_constant(gtk_ce, "PRIORITY_DEFAULT_IDLE", sizeof("PRIORITY_DEFAULT_IDLE")-1, G_PRIORITY_DEFAULT_IDLE);
    phpg_register_int_constant(gtk_ce, "PRIORITY_LOW", sizeof("PRIORITY_LOW")-1, G_PRIORITY_LOW);


    phpg_register_int_constant(gtk_ce, "IO_IN", sizeof("IO_IN")-1, G_IO_IN);
    phpg_register_int_constant(gtk_ce, "IO_OUT", sizeof("IO_OUT")-1, G_IO_OUT);
    phpg_register_int_constant(gtk_ce, "IO_PRI", sizeof("IO_PRI")-1, G_IO_PRI);
    phpg_register_int_constant(gtk_ce, "IO_ERR", sizeof("IO_ERR")-1, G_IO_ERR);
    phpg_register_int_constant(gtk_ce, "IO_HUP", sizeof("IO_HUP")-1, G_IO_HUP);
    phpg_register_int_constant(gtk_ce, "IO_NVAL", sizeof("IO_NVAL")-1, G_IO_NVAL);


    /* Fundamental GTypes */
    phpg_register_int_constant(gtk_ce, "TYPE_INVALID", sizeof("TYPE_INVALID")-1, G_TYPE_INVALID);
    phpg_register_int_constant(gtk_ce, "TYPE_NONE", sizeof("TYPE_NONE")-1, G_TYPE_NONE);
    phpg_register_int_constant(gtk_ce, "TYPE_INTERFACE", sizeof("TYPE_INTERFACE")-1, G_TYPE_INTERFACE);
    phpg_register_int_constant(gtk_ce, "TYPE_CHAR", sizeof("TYPE_CHAR")-1, G_TYPE_CHAR);
    phpg_register_int_constant(gtk_ce, "TYPE_BOOLEAN", sizeof("TYPE_BOOLEAN")-1, G_TYPE_BOOLEAN);
    phpg_register_int_constant(gtk_ce, "TYPE_LONG", sizeof("TYPE_LONG")-1, G_TYPE_LONG);
    phpg_register_int_constant(gtk_ce, "TYPE_ENUM", sizeof("TYPE_ENUM")-1, G_TYPE_ENUM);
    phpg_register_int_constant(gtk_ce, "TYPE_FLAGS", sizeof("TYPE_FLAGS")-1, G_TYPE_FLAGS);
    phpg_register_int_constant(gtk_ce, "TYPE_DOUBLE", sizeof("TYPE_DOUBLE")-1, G_TYPE_DOUBLE);
    phpg_register_int_constant(gtk_ce, "TYPE_STRING", sizeof("TYPE_STRING")-1, G_TYPE_STRING);
    phpg_register_int_constant(gtk_ce, "TYPE_POINTER", sizeof("TYPE_POINTER")-1, G_TYPE_POINTER);
    phpg_register_int_constant(gtk_ce, "TYPE_BOXED", sizeof("TYPE_BOXED")-1, G_TYPE_BOXED);
    phpg_register_int_constant(gtk_ce, "TYPE_PARAM", sizeof("TYPE_PARAM")-1, G_TYPE_PARAM);
    phpg_register_int_constant(gtk_ce, "TYPE_OBJECT", sizeof("TYPE_OBJECT")-1, G_TYPE_OBJECT);
    phpg_register_int_constant(gtk_ce, "TYPE_PHP_VALUE", sizeof("TYPE_PHP_VALUE")-1, G_TYPE_PHP_VALUE);
%% }}}

%% {{{ main loop

%%
add-arginfo Gtk timeout_add
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, interval)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_timeout_add

static void phpg_gtk_timeout_add_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool with_priority)
{
    guint interval;
    gint priority = G_PRIORITY_DEFAULT;
    zval *callback = NULL;
    zval *extra;
    zval *data = NULL;
    char *callback_filename;
    uint callback_lineno;
    guint handler_id;
    int req_args = with_priority ? 3 : 2;

    if (ZEND_NUM_ARGS() < req_args) {
        php_error(E_WARNING, "%s::%s() requires at least %d arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), req_args, ZEND_NUM_ARGS());
        return;
    }

    if (with_priority) {
        if (!php_gtk_parse_args(req_args, "iiV", &interval, &priority, &callback))
            return;
    } else {
        if (!php_gtk_parse_args(req_args, "iV", &interval, &callback))
            return;
    }

    callback_filename = zend_get_executed_filename(TSRMLS_C);
    callback_lineno = zend_get_executed_lineno(TSRMLS_C);
    extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), req_args, ZEND_NUM_ARGS());
    if (!extra) {
        MAKE_STD_ZVAL(extra);
        array_init(extra);
    }
    php_gtk_build_value(&data, "(VNsi)", callback, extra, callback_filename, callback_lineno);

    handler_id = g_timeout_add_full(priority, interval, phpg_handler_marshal, data, phpg_destroy_notify);
    RETURN_LONG(handler_id);
}

PHP_METHOD
{
    phpg_gtk_timeout_add_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}

%%
add-arginfo Gtk timeout_add_priority
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, interval)
    ZEND_ARG_INFO(0, priority)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
add Gtk timeout_add_priority
PHP_METHOD
{
    phpg_gtk_timeout_add_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}

%%
override gtk_idle_add

static void phpg_gtk_idle_add_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool with_priority)
{
    gint priority = G_PRIORITY_DEFAULT;
    zval *callback = NULL;
    zval *extra = NULL;
    zval *data = NULL;
    char *callback_filename;
    uint callback_lineno;
    guint handler_id;
    int req_args = with_priority ? 2 : 1;

    if (ZEND_NUM_ARGS() < req_args) {
        php_error(E_WARNING, "%s::%s() requires at least %d arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), req_args, ZEND_NUM_ARGS());
        return;
    }

    if (with_priority) {
        if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), req_args, &extra, "iV", &priority, &callback))
            return;
    } else {
        if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), req_args, &extra, "V", &callback))
            return;
    }

    callback_filename = zend_get_executed_filename(TSRMLS_C);
    callback_lineno = zend_get_executed_lineno(TSRMLS_C);
    php_gtk_build_value(&data, "(VNsi)", callback, extra, callback_filename, callback_lineno);

    handler_id = g_idle_add_full(priority, phpg_handler_marshal, data, phpg_destroy_notify);
    RETURN_LONG(handler_id);
}

PHP_METHOD
{
    phpg_gtk_idle_add_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}

%%          
override gtk_idle_add_priority
PHP_METHOD 
{           
    phpg_gtk_idle_add_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}

%%
add Gtk get_version
PHP_METHOD
{
    guint major;
    guint minor;
    guint micro;
    char version[256];

    major = GTK_MAJOR_VERSION;
    minor = GTK_MINOR_VERSION;
    micro = GTK_MICRO_VERSION;

    snprintf(version, sizeof(version), "GTK %d.%d.%d", major, minor, micro);

    RETURN_STRING(version, 1);
}

%%
add-arginfo Gtk quit_add
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, main_level)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_quit_add

PHP_METHOD
{
    guint main_level;
    zval *callback = NULL;
    zval *extra;
    zval *data = NULL;
    char *callback_filename;
    uint callback_lineno;
    guint handler_id;

    if (ZEND_NUM_ARGS() < 2) {
        php_error(E_WARNING, "%s::%s() requires at least 2 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), ZEND_NUM_ARGS());
        return;
    }

    if (!php_gtk_parse_args(2, "iV", &main_level, &callback))
        return;

    callback_filename = zend_get_executed_filename(TSRMLS_C);
    callback_lineno = zend_get_executed_lineno(TSRMLS_C);
    extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 2, ZEND_NUM_ARGS());
    if (!extra) {
        MAKE_STD_ZVAL(extra);
        array_init(extra);
    }
    php_gtk_build_value(&data, "(VNsi)", callback, extra, callback_filename, callback_lineno);

    handler_id = gtk_quit_add_full(main_level, phpg_handler_marshal, NULL, data, phpg_destroy_notify);
    RETURN_LONG(handler_id);
}

%%
add Gtk io_add_watch

static gboolean phpg_iowatch_marshal(GIOChannel *source, GIOCondition condition, gpointer user_data)
{
    zval *callback_data = (zval *) user_data;
    zval **callback, **extra = NULL, **stream_rsrc;
    zval **callback_filename = NULL, **callback_lineno = NULL;
    zval ***args = NULL, *z_condition = NULL;
    int n_args = 0;
    zval *retval = NULL;
    char *callback_name;
    gboolean result;
    TSRMLS_FETCH();

    /* Callback is always passed as the first element. */
    zend_hash_index_find(Z_ARRVAL_P(callback_data), 0, (void **)&callback);
    zend_hash_index_find(Z_ARRVAL_P(callback_data), 1, (void **)&stream_rsrc);
    zend_hash_index_find(Z_ARRVAL_P(callback_data), 2, (void **)&extra);
    zend_hash_index_find(Z_ARRVAL_P(callback_data), 3, (void **)&callback_filename);
    zend_hash_index_find(Z_ARRVAL_P(callback_data), 4, (void **)&callback_lineno);

    if (!zend_is_callable(*callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke handler callback '%s' specified in %s on line %ld", callback_name, Z_STRVAL_PP(callback_filename), Z_LVAL_PP(callback_lineno));
        efree(callback_name);
        return 0;
    }

    args = php_gtk_hash_as_array_offset(*extra, 2, &n_args);
    args[0] = stream_rsrc;
    MAKE_STD_ZVAL(z_condition);
    ZVAL_LONG(z_condition, condition);
    args[1] = &z_condition;

    call_user_function_ex(EG(function_table), NULL, *callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&z_condition);

    result = FALSE;
    if (retval) {
        result = zval_is_true(retval);
        zval_ptr_dtor(&retval);
    }

    efree(callback_name);
    if (args)
        efree(args);

    return result;
}

static void phpg_io_add_watch_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool with_priority)
{
    gint priority = G_PRIORITY_DEFAULT;
    GIOCondition condition;
    zval *stream_rsrc = NULL;
    zval *callback = NULL;
    zval *extra = NULL;
    zval *data = NULL;
    char *callback_filename;
    uint callback_lineno;
    guint handler_id;
    GIOChannel *channel = NULL;
    php_stream *stream = NULL;
    int fd;
    int req_args = with_priority ? 4 : 3;

    if (ZEND_NUM_ARGS() < req_args) {
        php_error(E_WARNING, "%s::%s() requires at least %d arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), req_args, ZEND_NUM_ARGS());
        return;
    }

    if (with_priority) {
        if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), req_args, &extra, "riVi", &stream_rsrc, &condition, &callback, &priority))
            return;
    } else {
        if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), req_args, &extra, "riV", &stream_rsrc, &condition, &callback))
            return;
    }

    php_stream_from_zval(stream, &stream_rsrc);
    if (php_stream_can_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT) == SUCCESS) {
        php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT, (void*)&fd, 0);
    } else {
        php_error(E_WARNING, "%s::%s() could not use stream of type '%s'",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), stream->ops->label);
        return;
    }

    if (!extra) {
        MAKE_STD_ZVAL(extra);
        array_init(extra);
    }

    channel = g_io_channel_unix_new(fd);
    callback_filename = zend_get_executed_filename(TSRMLS_C);
    callback_lineno = zend_get_executed_lineno(TSRMLS_C);
    php_gtk_build_value(&data, "(VVNsi)", callback, stream_rsrc, extra, callback_filename, callback_lineno);
    handler_id = g_io_add_watch_full(channel, priority, condition, phpg_iowatch_marshal, data, phpg_destroy_notify);
    g_io_channel_unref(channel);

    RETURN_LONG(handler_id);
}

PHP_METHOD
{
    phpg_io_add_watch_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}

%%
add Gtk io_add_watch_priority

PHP_METHOD
{
    phpg_io_add_watch_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}

%% }}}

%% {{{ functions

%%
add-arginfo Gtk icon_size_lookup
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, size)
ZEND_END_ARG_INFO();

%%
override gtk_icon_size_lookup
PHP_METHOD
{
    gint width, height;
    zval *php_size = NULL;
    GtkIconSize size;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_size))
        return;

    if (php_size && phpg_gvalue_get_enum(GTK_TYPE_ICON_SIZE, php_size, (gint *)&size) == FAILURE) {
        return;
    }

    gtk_icon_size_lookup(size, &width, &height);

    php_gtk_build_value(&return_value, "(ii)", width, height);
}


%%
add-arginfo Gtk icon_size_lookup_for_settings
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, settings, GtkSettings, 0)
    ZEND_ARG_INFO(0, size)
ZEND_END_ARG_INFO();

%%
override gtk_icon_size_lookup_for_settings
PHP_METHOD
{
    gint width, height;
    zval *php_settings;
    zval *php_size = NULL;
    GtkIconSize size;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "OV", &php_settings, gtksettings_ce, &php_size))
        return;

    if (php_size && phpg_gvalue_get_enum(GTK_TYPE_ICON_SIZE, php_size, (gint *)&size) == FAILURE)
        return;


    if (gtk_icon_size_lookup_for_settings(GTK_SETTINGS(PHPG_GOBJECT(php_settings)), size, &width, &height)) {
        php_gtk_build_value(&return_value, "(ii)", width, height);
    } else {
        RETURN_FALSE;
    }
}


%%
override gtk_rc_get_default_files
PHP_METHOD(gtk_rc_get_default_files)
{
    gchar **ret;
    gchar *cp_str;
    gsize cp_len;
    zend_bool free_cp_str;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    ret = gtk_rc_get_default_files();
    if (ret) {
        array_init(return_value);
        while (*ret) {
            cp_str = phpg_from_utf8(*ret, strlen(*ret), &cp_len, &free_cp_str TSRMLS_CC);
            if (cp_str) {
                add_next_index_stringl(return_value, cp_str, cp_len, !free_cp_str);
            } else {
                zval_dtor(return_value);
                RETURN_NULL();
            }
            *ret++;
        }
    } else {
        RETURN_NULL();
    }
}


%%
override gtk_stock_list_ids
PHP_METHOD
{
    GSList *ids;

    array_init(return_value);
    for (ids = gtk_stock_list_ids(); ids; ids = ids->next) {
        add_next_index_string(return_value, (char *) ids->data, 1);
        g_free(ids->data);
    }
    g_slist_free(ids);
}

%%
add-arginfo Gtk stock_lookup
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, stock_id)
ZEND_END_ARG_INFO();

%%
override gtk_stock_lookup
PHP_METHOD
{
    char *stock_id;
    GtkStockItem item;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &stock_id))
        return;

    if (gtk_stock_lookup(stock_id, &item)) {
        php_gtk_build_value(&return_value, "(ssiis)", item.stock_id, item.label,
                            item.modifier, item.keyval, item.translation_domain);
    } else {
        return;
    }
}
%% }}}

%% {{{ GtkAdjustment

%%
add-arginfo GtkAdjustment __construct
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, value)
    ZEND_ARG_INFO(0, lower)
    ZEND_ARG_INFO(0, upper)
    ZEND_ARG_INFO(0, step_incr)
    ZEND_ARG_INFO(0, page_incr)
    ZEND_ARG_INFO(0, page_size)
ZEND_END_ARG_INFO();

%%
override gtk_adjustment_new
PHP_METHOD
{
    gdouble value = 0;
    gdouble lower = 0;
    gdouble upper = 0;
    gdouble step_incr = 0;
    gdouble page_incr = 0;
    gdouble page_size = 0;
    GObject *wrapped_obj;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|dddddd", &value, &lower, &upper,
                            &step_incr, &page_incr, &page_size))
        return;

    wrapped_obj = g_object_new(phpg_gtype_from_zval(this_ptr),
                               "value", value, "lower", lower,
                               "upper", upper, "step_increment", step_incr,
                               "page_increment", page_incr, "page_size", page_size, NULL);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkAdjustment);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%% }}}

%% {{{ GtkAdjustment

%%
override gtk_alignment_get_padding
PHP_METHOD
{
    gint padding_top, padding_bottom, padding_left, padding_right;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_alignment_get_padding(GTK_ALIGNMENT(PHPG_GOBJECT(this_ptr)), &padding_top, &padding_bottom, &padding_left, &padding_right);

    php_gtk_build_value(&return_value, "(iiii)", padding_top, padding_bottom, padding_left, padding_right);
}

%% }}}


%% {{{ GtkButton

%%
add-arginfo GtkButton __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_button_new
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *text = NULL;
    zend_bool free_text = FALSE, use_underline = 1;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ub", &text, &free_text, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
    }

    if (text) {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label",
                                              text, "use-underline", use_underline, NULL);
    } else {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
add-arginfo GtkButton new_from_stock
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, stock_id)
ZEND_END_ARG_INFO();

%%
override gtk_button_new_from_stock new_from_stock ZEND_ACC_PUBLIC|ZEND_ACC_STATIC
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *stock_id = NULL;
    zend_bool free_stock_id;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u", &stock_id, &free_stock_id)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
    }

    wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_class(EG(scope)), "label", stock_id,
                                          "use-stock", TRUE, "use-underline", TRUE, NULL);

    if (free_stock_id) g_free(stock_id);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
    }

    phpg_gobject_new(&return_value, wrapped_obj TSRMLS_CC);
    g_object_unref(wrapped_obj); /* phpg_gobject_new() increments reference count */
}


%%
override gtk_button_get_alignment
PHP_METHOD
{
    gfloat xalign, yalign;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_button_get_alignment(GTK_BUTTON(PHPG_GOBJECT(this_ptr)), &xalign, &yalign);
    //FIXME: bad precision (set 0.1 -> get 0.10000000149012)
    php_gtk_build_value(&return_value, "(ff)", xalign, yalign);
}

%% }}}


%% {{{ GtkButtonBox

%%
override gtk_button_box_get_child_size
PHP_METHOD
{
    gint min_width, min_height;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    phpg_warn_deprecated("use style properties \"child-min-width/-height\" instead" TSRMLS_CC);

    gtk_button_box_get_child_size(GTK_BUTTON_BOX(PHPG_GOBJECT(this_ptr)), &min_width, &min_height);
    php_gtk_build_value(&return_value, "(ii)", min_width, min_height);
}

%%
override gtk_button_box_get_child_ipadding
PHP_METHOD
{
    gint ipad_x, ipad_y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    phpg_warn_deprecated("use style properties \"child-internal-pad-x/-y\" instead" TSRMLS_CC);

    gtk_button_box_get_child_size(GTK_BUTTON_BOX(PHPG_GOBJECT(this_ptr)), &ipad_x, &ipad_y);
    php_gtk_build_value(&return_value, "(ii)", ipad_x, ipad_y);
}

%% }}}

%% {{{ GtkCheckButton
%%
add-arginfo GtkCheckButton __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_check_button_new
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *text = NULL;
    zend_bool free_text = FALSE, use_underline = 1;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ub", &text, &free_text, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkCheckButton);
    }

    if (text) {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label",
                                              text, "use-underline", use_underline, NULL);
    } else {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkCheckButton);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkCheckMenuItem
%%
add-arginfo GtkCheckMenuItem __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_check_menu_item_new
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *text = NULL;
    zend_bool free_text = FALSE, use_underline = 1;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ub", &text, &free_text, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMenuItem);
    }

    wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(wrapped_obj), accel_label);
        if (use_underline)
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label), GTK_WIDGET(wrapped_obj));
        gtk_widget_show(accel_label);
    }

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMenuItem);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}


%% {{{ GtkCList

%%
add-arginfo GtkCList get_selection_info
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, x)
    ZEND_ARG_INFO(0, y)
ZEND_END_ARG_INFO();

%%
override gtk_clist_get_selection_info
PHP_METHOD
{
    gint x, y, row, column;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ii", &x, &y)) {
        php_error(E_WARNING, "%s::%s() requires 2 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), ZEND_NUM_ARGS());
        return;
    }

    phpg_warn_deprecated(NULL TSRMLS_CC);

    if (gtk_clist_get_selection_info(GTK_CLIST(PHPG_GOBJECT(this_ptr)), x, y, &row, &column) == 0) {
        RETURN_FALSE;
    } else {
        php_gtk_build_value(&return_value, "(ii)", row, column);
    }
}

%% }}}


%% {{{ GtkColorSelection
%%
override gtk_color_selection_get_current_color
PHP_METHOD
{

    GdkColor color = { 0 , 0 , 0 , 0 };

    if (ZEND_NUM_ARGS() > 0) {
        php_error(E_WARNING, "%s::%s() requires 0 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), ZEND_NUM_ARGS());
        return;
    }

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(PHPG_GOBJECT(this_ptr)), &color);
    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);

}

%%
override gtk_color_selection_get_previous_color
PHP_METHOD
{

    GdkColor color = { 0 , 0 , 0 , 0 };

    if (ZEND_NUM_ARGS() > 0) {
        php_error(E_WARNING, "%s::%s() requires 0 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC),
                  get_active_function_name(TSRMLS_C), ZEND_NUM_ARGS());
        return;
    }

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(PHPG_GOBJECT(this_ptr)), &color);
    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);

}
%% }}}

%% {{{ GtkCombo

%%
add-arginfo GtkCombo set_popdown_strings
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, strings)
ZEND_END_ARG_INFO();

%%
override gtk_combo_set_popdown_strings
PHP_METHOD
{
    zval *php_strings, **item;
    GList *strings = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &php_strings)) {
        return;
    }

    zend_hash_internal_pointer_reset(Z_ARRVAL_P(php_strings));

    while (zend_hash_get_current_data(Z_ARRVAL_P(php_strings), (void **)&item) == SUCCESS) {

        gchar *utf8 = NULL;
        gsize utf8_len = 0;
        zend_bool free_utf8 = 0;

        convert_to_string_ex(item);
        utf8 = phpg_to_utf8(Z_STRVAL_PP(item), Z_STRLEN_PP(item), &utf8_len, &free_utf8 TSRMLS_CC);

        if (utf8 && free_utf8) {
            SEPARATE_ZVAL(item);
            zval_dtor(*item);
            ZVAL_STRINGL(*item, utf8, utf8_len, 1);
            g_free(utf8);
        }

        strings = g_list_append(strings, Z_STRVAL_PP(item));
        zend_hash_move_forward(Z_ARRVAL_P(php_strings));
    }

    gtk_combo_set_popdown_strings(GTK_COMBO(PHPG_GOBJECT(this_ptr)), strings);

    g_list_free(strings);
}
%% }}}

%% include gtkcontainer.overrides

%% {{{ GtkDialog

%%
add-arginfo GtkDialog __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, title)
    ZEND_ARG_OBJ_INFO(0, parent, GtkWindow, 1)
    ZEND_ARG_INFO(0, flags)
    ZEND_ARG_INFO(0, buttons)
ZEND_END_ARG_INFO();

%%
override gtk_dialog_new_with_buttons
PHP_METHOD
{
    char *title = NULL;
    zend_bool free_title;
    GtkWindow *parent = NULL;
    zval *php_parent = NULL, *php_flags = NULL;
    zval *buttons = NULL;
    GtkDialogFlags flags = 0;
    GObject *wrapped_obj;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|uNVa", &title, &free_title, &php_parent, gtkwindow_ce, &php_flags, &buttons)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
    }
    if (php_parent) {
        if (Z_TYPE_P(php_parent) == IS_NULL)
            parent = NULL;
        else
            parent = GTK_WINDOW(PHPG_GOBJECT(php_parent));
    }

    if (php_flags && phpg_gvalue_get_flags(GTK_TYPE_DIALOG_FLAGS, php_flags, (gint *)&flags) == FAILURE) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
    }

    wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
    }

    if (title) {
        gtk_window_set_title(GTK_WINDOW(wrapped_obj), title);
    }
    if (free_title) g_free(title);

    if (parent) {
        gtk_window_set_transient_for(GTK_WINDOW(wrapped_obj), parent);
    }
    if (flags & GTK_DIALOG_MODAL) {
        gtk_window_set_modal(GTK_WINDOW(wrapped_obj), TRUE);
    }
    if (flags & GTK_DIALOG_DESTROY_WITH_PARENT) {
        gtk_window_set_destroy_with_parent (GTK_WINDOW(wrapped_obj), TRUE);
    }
    if (flags & GTK_DIALOG_NO_SEPARATOR) {
        gtk_dialog_set_has_separator (GTK_DIALOG(wrapped_obj), FALSE);
    }

    if (buttons) {
        zval **text, **response;

        if (zend_hash_num_elements(Z_ARRVAL_P(buttons)) % 2) {
            php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
            gtk_object_destroy(GTK_OBJECT(wrapped_obj));
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
        }

        zend_hash_internal_pointer_reset(Z_ARRVAL_P(buttons));
        while (zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&text) == SUCCESS) {
            zend_hash_move_forward(Z_ARRVAL_P(buttons));
            zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&response); /* safe */
            zend_hash_move_forward(Z_ARRVAL_P(buttons));

            if (Z_TYPE_PP(text) != IS_STRING || Z_TYPE_PP(response) != IS_LONG) {
                php_error(E_WARNING, "%s::%s(): each pair in button list has to be string/number",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
                gtk_object_destroy(GTK_OBJECT(wrapped_obj));
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
            }

            gtk_dialog_add_button(GTK_DIALOG(wrapped_obj), Z_STRVAL_PP(text), Z_LVAL_PP(response));
        }
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}


%%
add-arginfo GtkDialog add_buttons
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, buttons)
ZEND_END_ARG_INFO();

%%
override gtk_dialog_add_buttons
PHP_METHOD
{
    zval *buttons = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &buttons))
        return;

    zval **text, **response;

    if (zend_hash_num_elements(Z_ARRVAL_P(buttons)) % 2) {
        php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
                    get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    zend_hash_internal_pointer_reset(Z_ARRVAL_P(buttons));
    while (zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&text) == SUCCESS) {
        zend_hash_move_forward(Z_ARRVAL_P(buttons));
        zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&response); /* safe */
        zend_hash_move_forward(Z_ARRVAL_P(buttons));

        if (Z_TYPE_PP(text) != IS_STRING || Z_TYPE_PP(response) != IS_LONG) {
            php_error(E_WARNING, "%s::%s(): each pair in button list has to be string/number",
                        get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
            return;
        }

        gtk_dialog_add_button(GTK_DIALOG(PHPG_GOBJECT(this_ptr)), Z_STRVAL_PP(text), Z_LVAL_PP(response));
    }
}

%% }}}


%% {{{ GtkEditable

%%
override gtk_editable_get_selection_bounds
PHP_METHOD
{
    gint start, end;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(PHPG_GOBJECT(this_ptr)), &start, &end)) {
        RETURN_FALSE;
    } else {
        php_gtk_build_value(&return_value, "(ii)", start, end);
    }
}


%%
add-arginfo GtkEditable insert_text
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, position)
ZEND_END_ARG_INFO();

%%
override gtk_editable_insert_text
PHP_METHOD
{
    char *text;
    gint pos;
    int text_len;
    zend_bool free_text;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "iu#", &pos, &text, &text_len, &free_text))
        return;

    gtk_editable_insert_text(GTK_EDITABLE(PHPG_GOBJECT(this_ptr)), text, text_len, &pos);

    if (free_text) g_free(text);

    RETURN_LONG(pos);
}

%% }}}


%% {{{ GtkEntry

%%
add-arginfo GtkEntry __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, max_length)
ZEND_END_ARG_INFO();

%%
override gtk_entry_new
PHP_METHOD
{
    gchararray text = "";
    int max = 0;
    zend_bool free_text = FALSE;
	GObject *wrapped_obj;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ui", &text, &free_text, &max)) {
        return;
    }

    wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr),
                                          "max-length", max, "text", text, NULL);

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkEntry);
    }
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_entry_get_layout_offsets
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_entry_get_layout_offsets(GTK_ENTRY(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}

%% }}}


%% {{{ GtkFrame

%%
override gtk_frame_get_label_align
PHP_METHOD
{
    gfloat xalign, yalign;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_frame_get_label_align(GTK_FRAME(PHPG_GOBJECT(this_ptr)), &xalign, &yalign);

    php_gtk_build_value(&return_value, "(ff)", xalign, yalign);
}

%% }}}


%% {{{ GtkIconSet
%%
override gtk_icon_set_get_sizes
PHP_METHOD
{
    GtkIconSize *sizes;
    gint n_sizes, i;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_icon_set_get_sizes((GtkIconSet *)PHPG_GBOXED(this_ptr), &sizes, &n_sizes);
    array_init(return_value);

    for (i = 0; i < n_sizes; i++) {
        add_next_index_long(return_value, sizes[i]);
    }

    g_free(sizes);
}
%% }}}

%% {{{ GtkImageMenuItem
%%
add-arginfo GtkImageMenuItem __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, stock_id)
    ZEND_ARG_OBJ_INFO(0, accel_group, GtkAccelGroup, 1)
ZEND_END_ARG_INFO();

%%
override gtk_image_menu_item_new
PHP_METHOD
{
	char *stock_id = NULL;
	zend_bool free_stock_id;
	zval *php_accel_group = NULL;
    GtkAccelGroup *accel_group = NULL;
	GObject *wrapped_obj;

    if (phpg_gtype_from_zval(this_ptr) != GTK_TYPE_IMAGE_MENU_ITEM) {
        PHPG_THROW_EXCEPTION(phpg_construct_exception, "Subclassing GtkImageMenuItem requires more than you know");
        return;
    }

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|uO", &stock_id, &free_stock_id, &php_accel_group, gtkaccelgroup_ce)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkImageMenuItem);
	}
    
    if (php_accel_group) {
        accel_group = GTK_ACCEL_GROUP(PHPG_GOBJECT(php_accel_group));
    }

    if (stock_id) {
        wrapped_obj = (GObject *) gtk_image_menu_item_new_from_stock(stock_id, accel_group);
    } else {
        wrapped_obj = (GObject *) gtk_image_menu_item_new();
    }
	if (free_stock_id) g_free(stock_id);

	if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkImageMenuItem);
	}
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkFileChooserDialog

%%
add-arginfo GtkFileChooserDialog __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, title)
    ZEND_ARG_OBJ_INFO(0, parent, GtkWindow, 1)
    ZEND_ARG_INFO(0, action)
    ZEND_ARG_INFO(0, buttons)
    ZEND_ARG_INFO(0, backend)
ZEND_END_ARG_INFO();

%%
override gtk_file_chooser_dialog_new_with_backend
PHP_METHOD
{
    char *title = NULL, *backend = NULL;
    zend_bool free_title, free_backend;
    zval *php_parent = NULL, *php_action = NULL;
    zval *buttons = NULL;
    GtkWindow *parent = NULL;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
    GObject *wrapped_obj;
    int n = 0;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|uNVau", &title, &free_title, &php_parent,
                            gtkwindow_ce, &php_action, &buttons, &backend, &free_backend)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
    }

    if (php_parent) {
        if (Z_TYPE_P(php_parent) == IS_NULL)
            parent = NULL;
        else
            parent = GTK_WINDOW(PHPG_GOBJECT(php_parent));
    }

    if (php_action && phpg_gvalue_get_enum(GTK_TYPE_FILE_CHOOSER_ACTION, php_action, (gint *)&action) == FAILURE) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
    }

    if (buttons) {
        n = zend_hash_num_elements(Z_ARRVAL_P(buttons));
    }
    if (n % 2) {
        php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
    }

    wrapped_obj = (GObject *) g_object_new(phpg_gtype_from_zval(this_ptr),
                                           "title", title,
                                           "action", action,
                                           "file-system-backend", backend, NULL);

    if (free_title) g_free(title);
    if (free_backend) g_free(backend);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
    }

    if (parent) {
        gtk_window_set_transient_for(GTK_WINDOW(wrapped_obj), parent);
    }

    if (buttons) {
        zval **text, **response;

        if (zend_hash_num_elements(Z_ARRVAL_P(buttons)) % 2) {
            php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
            gtk_object_destroy(GTK_OBJECT(wrapped_obj));
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
        }

        zend_hash_internal_pointer_reset(Z_ARRVAL_P(buttons));
        while (zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&text) == SUCCESS) {
            zend_hash_move_forward(Z_ARRVAL_P(buttons));
            zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&response); /* safe */
            zend_hash_move_forward(Z_ARRVAL_P(buttons));

            if (Z_TYPE_PP(text) != IS_STRING || Z_TYPE_PP(response) != IS_LONG) {
                php_error(E_WARNING, "%s::%s(): each pair in button list has to string/number",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
                gtk_object_destroy(GTK_OBJECT(wrapped_obj));
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
            }

            gtk_dialog_add_button(GTK_DIALOG(wrapped_obj), Z_STRVAL_PP(text), Z_LVAL_PP(response));
        }
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkLabel
%%
add-arginfo GtkLabel __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_label_new
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *text = NULL;
    zend_bool free_text = FALSE, use_underline = 0;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ub", &text, &free_text, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkLabel);
    }

    if (text) {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label", text,
                                              "use-underline", use_underline, NULL);
    } else {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkLabel);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_label_get
PHP_METHOD
{
    gchar *text = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_label_get(GTK_LABEL(PHPG_GOBJECT(this_ptr)), &text);
    if (text) {
        RETURN_STRING(text, 1);
    } else {
        RETURN_EMPTY_STRING();
    }
}
%%
override gtk_label_get_selection_bounds
PHP_METHOD
{
    gint start, end;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_label_get_selection_bounds(GTK_LABEL(PHPG_GOBJECT(this_ptr)), &start, &end);
    php_gtk_build_value(&return_value, "(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_label_get_layout_offsets(GTK_LABEL(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}
%% }}}


%% {{{ GtkLayout

%%
override gtk_layout_get_size
PHP_METHOD
{
    gint width, height;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_layout_get_size(GTK_LAYOUT(PHPG_GOBJECT(this_ptr)), &width, &height);
    php_gtk_build_value(&return_value, "(ii)", width, height);
}

%% }}}


%% {{{ GtkMenu
%%
add-arginfo GtkMenu popup
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 2)
    ZEND_ARG_INFO(0, x)
    ZEND_ARG_INFO(0, y)
    ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO();

%%
override gtk_menu_popup
static void php_gtk_menu_position(GtkMenu *menu, int *x, int *y, int *push_in, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    char *callback_name;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "unable to call menu position callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return;
    }

    if (cbd->user_args) {
        args = php_gtk_hash_as_array_offset(cbd->user_args, 0, &n_args);
    }

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    if (retval) {
        if (Z_TYPE_P(retval) == IS_ARRAY && !php_gtk_parse_args_hash_quiet(retval, "ii|b", x, y, push_in)) {
            php_error(E_WARNING, "unable to parse result of menu position callback");
        }
        zval_ptr_dtor(&retval);
    }

    if (args) {
        efree(args);
    }

    efree(callback_name);
    phpg_cb_data_destroy(data);
}

PHP_METHOD
{
    GtkWidget *pms = NULL, *pmi = NULL;
    zval *php_pms = NULL, *php_pmi = NULL;
    zval *callback = NULL, *user_args = NULL;
    int button = 0, time = 0;
    phpg_cb_data_t *data;

    NOT_STATIC_METHOD();

    if (ZEND_NUM_ARGS() > 5) {
        if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 5, &user_args, "NNVii", &php_pms, gtkwidget_ce, &php_pmi, gtkwidget_ce, &callback, &button, &time)) {
            return;
        }
    } else {
        if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|NNVii", &php_pms, gtkwidget_ce, &php_pmi, gtkwidget_ce, &callback, &button, &time)) {
            return;
        }
    }

    if (php_pms && Z_TYPE_P(php_pms) != IS_NULL)
        pms = GTK_WIDGET(PHPG_GOBJECT(php_pms));
    if (php_pmi && Z_TYPE_P(php_pmi) != IS_NULL)
        pmi = GTK_WIDGET(PHPG_GOBJECT(php_pmi));
    if (!time)
        time = gtk_get_current_event_time();

    if (callback && Z_TYPE_P(callback) != IS_NULL) {

        zval_add_ref(&callback);
        data = phpg_cb_data_new(callback, user_args TSRMLS_CC);

        gtk_menu_popup(GTK_MENU(PHPG_GOBJECT(this_ptr)), pms, pmi, 
        (GtkMenuPositionFunc)php_gtk_menu_position, data, button, time);

    } else {

        gtk_menu_popup(GTK_MENU(PHPG_GOBJECT(this_ptr)), pms, pmi, NULL, NULL, button, time);
    }
}
%% }}}

%% {{{ GtkMessageDialog
%%
add-arginfo GtkMessageDialog __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, parent, GtkWindow, 1)
    ZEND_ARG_INFO(0, flags)
    ZEND_ARG_INFO(0, type)
    ZEND_ARG_INFO(0, buttons)
    ZEND_ARG_INFO(0, message)
ZEND_END_ARG_INFO();

%%
override gtk_message_dialog_new
PHP_METHOD
{
    GtkWindow *parent = NULL;
    zval *php_parent = NULL, *php_flags = NULL, *php_type = NULL, *php_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkMessageType type = GTK_MESSAGE_INFO;
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    char *message = NULL;
    zend_bool free_message;
    GObject *wrapped_obj;

    if (phpg_gtype_from_zval(this_ptr) != GTK_TYPE_MESSAGE_DIALOG) {
        PHPG_THROW_EXCEPTION(phpg_construct_exception, "Subclassing GtkMessageDialog requires more than you know");
        return;
    }

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|NVVVu", &php_parent, gtkwindow_ce, &php_flags, &php_type, &php_buttons, &message, &free_message)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
    }

    if (php_parent) {
        if (Z_TYPE_P(php_parent) == IS_NULL)
            parent = NULL;
        else
            parent = GTK_WINDOW(PHPG_GOBJECT(php_parent));
    }

    if (php_flags && phpg_gvalue_get_flags(GTK_TYPE_DIALOG_FLAGS, php_flags, (gint *)&flags) == FAILURE) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
    }

    if (php_type && phpg_gvalue_get_enum(GTK_TYPE_MESSAGE_TYPE, php_type, (gint *)&type) == FAILURE) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
    }

    if (php_buttons && phpg_gvalue_get_enum(GTK_TYPE_BUTTONS_TYPE, php_buttons, (gint *)&buttons) == FAILURE) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
    }

    if (!message) {
        message = "";
    }

    wrapped_obj = (GObject *) gtk_message_dialog_new(parent, flags, type, buttons, "%s", message);

    if (free_message) g_free(message);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkMenuItem
%%
add-arginfo GtkMenuItem __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_menu_item_new
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *text = NULL;
    zend_bool free_text = FALSE, use_underline = 1;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ub", &text, &free_text, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMenuItem);
    }

    wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(wrapped_obj), accel_label);
        if (use_underline)
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label), GTK_WIDGET(wrapped_obj));
        gtk_widget_show(accel_label);
    }

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMenuItem);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);

}
%% }}}


%% {{{ GtkMisc

%%
override gtk_misc_get_alignment
PHP_METHOD
{
    gfloat xalign, yalign;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_misc_get_alignment(GTK_MISC(PHPG_GOBJECT(this_ptr)), &xalign, &yalign);
    php_gtk_build_value(&return_value, "(ff)", xalign, yalign);
}


%%
override gtk_misc_get_padding
PHP_METHOD
{
    gint xpad, ypad;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_misc_get_padding(GTK_MISC(PHPG_GOBJECT(this_ptr)), &xpad, &ypad);
    php_gtk_build_value(&return_value, "(ii)", xpad, ypad);
}

%% }}}


%% {{{ GtkProgressBar

%%
add-arginfo GtkProgressBar __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, adjustment, GtkAdjustment, 1)
ZEND_END_ARG_INFO();

%%
override gtk_progress_bar_new_with_adjustment
PHP_METHOD
{
	GtkAdjustment *adjustment = NULL;
	zval *php_adjustment = NULL;
	GObject *wrapped_obj;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|N", &php_adjustment, gtkadjustment_ce)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkProgressBar);
	}
    if (php_adjustment) {
        if (Z_TYPE_P(php_adjustment) == IS_NULL)
            adjustment = NULL;
        else
            adjustment = GTK_ADJUSTMENT(PHPG_GOBJECT(php_adjustment));
    }

    if (adjustment) {
        wrapped_obj = g_object_new(phpg_gtype_from_zval(this_ptr), "adjustment", adjustment, NULL);
    } else {
        wrapped_obj = g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

	if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkProgressBar);
	}
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%% }}}

%% {{{ GtkRadioMenuItem
%%
add-arginfo GtkRadioMenuItem __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, group, GtkRadioMenuItem, 1)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_radio_menu_item_new
PHP_METHOD
{
    zval *php_group = NULL;
    char *label = NULL;
    zend_bool free_label, use_underline = 1;
    GtkRadioMenuItem *group = NULL;
    GObject *wrapped_obj;
    GType gtype = phpg_gtype_from_zval(this_ptr);

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Nub", &php_group, gtkradiomenuitem_ce, &label, &free_label, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioButton);
    }

    if (php_group && Z_TYPE_P(php_group) != IS_NULL) {
        group = GTK_RADIO_MENU_ITEM(PHPG_GOBJECT(php_group));
    }

    wrapped_obj = (GObject *) g_object_new(gtype, NULL);

    if (label) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(wrapped_obj), accel_label);
        if (use_underline)
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), label);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), label);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label), GTK_WIDGET(wrapped_obj));
        gtk_widget_show(accel_label);
    }
    if (group) {
        gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(wrapped_obj), gtk_radio_menu_item_get_group(group));
    }

    if (free_label) g_free(label);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioButton);
    }
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);

}

%%
add-arginfo GtkRadioMenuItem set_group
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, group, GtkRadioMenuItem, 1)
ZEND_END_ARG_INFO();

%%
override gtk_radio_menu_item_set_group
PHP_METHOD
{
    zval *php_group = NULL;
    GtkRadioMenuItem *group = NULL;
    GSList *list;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_group, gtkradiomenuitem_ce)) {
        return;
    }

    group = GTK_RADIO_MENU_ITEM(PHPG_GOBJECT(php_group));
    list = gtk_radio_menu_item_get_group(group);
    if (list == gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(PHPG_GOBJECT(this_ptr)))) {
        return;
    }
    gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(PHPG_GOBJECT(this_ptr)), list);
}

%%
override gtk_radio_menu_item_get_group
PHP_METHOD
{
    GSList *list, *tmp;
    zval *item;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "")) {
        return;
    }

    list = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(PHPG_GOBJECT(this_ptr)));
    array_init(return_value);
    for (tmp = list; tmp; tmp = tmp->next) {
        MAKE_STD_ZVAL(item);
        phpg_gobject_new(&item, G_OBJECT(tmp->data) TSRMLS_CC);
        add_next_index_zval(return_value, item);
    }
}
/* }}} */

%% {{{ GtkRadioButton
%%
add-arginfo GtkRadioButton __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, group, GtkRadioButton, 1)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_radio_button_new
PHP_METHOD
{
    zval *php_group = NULL;
    char *label = NULL;
    zend_bool free_label, use_underline = 1;
    GtkRadioButton *group = NULL;
    GObject *wrapped_obj;
    GType gtype = phpg_gtype_from_zval(this_ptr);

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Nub", &php_group, gtkradiobutton_ce, &label, &free_label, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioButton);
    }

    if (php_group && Z_TYPE_P(php_group) != IS_NULL) {
        group = GTK_RADIO_BUTTON(PHPG_GOBJECT(php_group));
    }

    if (group) {
        if (label) {
            wrapped_obj = (GObject *) g_object_new(gtype, "group", group, "label", label,
                                                   "use-underline", use_underline, NULL);
        } else {
            wrapped_obj = (GObject *) g_object_new(gtype, "group", group, NULL);
        }
    } else {
        if (label) {
            wrapped_obj = (GObject *) g_object_new(gtype, "label", label, "use-underline",
                                                   use_underline, NULL);
        } else {
            wrapped_obj = (GObject *) g_object_new(gtype, NULL);
        }
    }

    if (free_label) g_free(label);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioButton);
    }
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%% }}}

%% {{{ GtkRadioToolButton
%%
add-arginfo GtkRadioToolButton __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, group, GtkRadioToolButton, 1)
    ZEND_ARG_INFO(0, stock_id)
ZEND_END_ARG_INFO();

%%
override gtk_radio_tool_button_new

PHP_METHOD
{
    zval *php_group = NULL;
    GtkRadioToolButton *group = NULL;
    char *stock_id = NULL;
    zend_bool free_stock_id;
    GObject *wrapped_obj;
    GType gtype = phpg_gtype_from_zval(this_ptr);

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Nu", &php_group, gtkradiotoolbutton_ce, &stock_id, &free_stock_id)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioToolButton);
    }

    if (php_group && Z_TYPE_P(php_group) != IS_NULL) {
        group = GTK_RADIO_TOOL_BUTTON(PHPG_GOBJECT(php_group));
    }

    if (group) {
        if (stock_id) {
            wrapped_obj = (GObject *) g_object_new(gtype, "group", group, "stock_id", stock_id, NULL);
        } else {
            wrapped_obj = (GObject *) g_object_new(gtype, "group", group, NULL);
        }
    } else {
        if (stock_id) {
            wrapped_obj = (GObject *) g_object_new(gtype, "stock_id", stock_id, NULL);
        } else {
            wrapped_obj = (GObject *) g_object_new(gtype, NULL);
        }
    }

    if (free_stock_id) g_free(stock_id);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioToolButton);
    }
    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}


%% {{{ GtkRuler

%%
override gtk_ruler_get_range
PHP_METHOD
{
    gdouble lower, upper, position, max_size;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_ruler_get_range(GTK_RULER(PHPG_GOBJECT(this_ptr)), &lower, &upper, &position, &max_size);
    php_gtk_build_value(&return_value, "(dddd)", lower, upper, position, max_size);
}

%% }}}


%% {{{ GtkScale

%%
override gtk_scale_get_layout_offsets
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_scale_get_layout_offsets(GTK_SCALE(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}

%% }}}


%% {{{ GtkScrolledWindow

%%
override gtk_scrolled_window_get_policy
PHP_METHOD
{
    GtkPolicyType hscrollbar_policy, vscrollbar_policy;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(PHPG_GOBJECT(this_ptr)), &hscrollbar_policy, &vscrollbar_policy);

    php_gtk_build_value(&return_value, "(ii)", (int)hscrollbar_policy, (int)vscrollbar_policy);
}

%% }}}


%% {{{ GtkSpinButton

%%
override gtk_spin_button_get_increments
PHP_METHOD
{
    gdouble step, page;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(PHPG_GOBJECT(this_ptr)), &step, &page);
    php_gtk_build_value(&return_value, "(dd)", step, page);
}

%%
override gtk_spin_button_get_range
PHP_METHOD
{
    gdouble min, max;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(PHPG_GOBJECT(this_ptr)), &min, &max);
    php_gtk_build_value(&return_value, "(dd)", min, max);
}

%% }}}



%% include gtkstyle.overrides

%% {{{ GtkTextAttributes

%%
override-prop GtkTextAttributes bg_color
PHPG_PROP_READER
{
    GdkColor php_retval;

    php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.bg_color;
    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &php_retval, TRUE, TRUE TSRMLS_CC);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes fg_color
PHPG_PROP_READER
{
    GdkColor php_retval;

    php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.fg_color;
    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &php_retval, TRUE, TRUE TSRMLS_CC);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes bg_stipple
PHPG_PROP_READER
{
    GdkBitmap *php_retval;

    php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.bg_stipple;
    phpg_gobject_new(&return_value, (GObject *)php_retval TSRMLS_CC);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes fg_stipple
PHPG_PROP_READER
{
    GdkBitmap *php_retval;

    php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.fg_stipple;
    phpg_gobject_new(&return_value, (GObject *)php_retval TSRMLS_CC);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes rise
PHPG_PROP_READER
{
    RETVAL_LONG(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.rise);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes underline
PHPG_PROP_READER
{
    RETVAL_LONG(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.underline);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes strikethrough
PHPG_PROP_READER
{
    RETVAL_LONG(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.strikethrough);

    return SUCCESS;
}

%%
override-prop GtkTextAttributes draw_bg
PHPG_PROP_READER
{
    RETVAL_BOOL(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.draw_bg);

    return SUCCESS;
}
%% }}}

%% {{{ GtkToggleButton
%%
add-arginfo GtkToggleButton __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, text)
    ZEND_ARG_INFO(0, use_underline)
ZEND_END_ARG_INFO();

%%
override gtk_toggle_button_new
PHP_METHOD
{
    GObject *wrapped_obj;
    gchar *text = NULL;
    zend_bool free_text = FALSE, use_underline = 1;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|ub", &text, &free_text, &use_underline)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkToggleButton);
    }

    if (text) {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label",
                                              text, "use-underline", use_underline, NULL);
    } else {
        wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

    if (free_text) g_free(text);

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkToggleButton);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}


%% {{{ GtkWidget

%%
override gtk_widget_get_child_requisition
PHP_METHOD
{
    GtkRequisition requisition;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_widget_get_child_requisition(GTK_WIDGET(PHPG_GOBJECT(this_ptr)), &requisition);
    phpg_gboxed_new(&return_value, GTK_TYPE_REQUISITION, &requisition, TRUE, TRUE TSRMLS_CC);
}

%%
override gtk_widget_get_pointer
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_widget_get_pointer(GTK_WIDGET(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}

%%
override gtk_widget_get_size_request
PHP_METHOD
{
    gint width, height;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_widget_get_size_request(GTK_WIDGET(PHPG_GOBJECT(this_ptr)), &width, &height);
    php_gtk_build_value(&return_value, "(ii)", width, height);
}


%%
add-arginfo GtkWidget intersect
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, area, GdkRectangle, 1)
ZEND_END_ARG_INFO();

%%
override gtk_widget_intersect
PHP_METHOD
{
    zval *php_area;
    GdkRectangle area, intersection;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_area))
        return;

    if (phpg_rectangle_from_zval(php_area, &area TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects area argument to be either a 4-element array or a GdkRectangle object", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }
    if (gtk_widget_intersect(GTK_WIDGET(PHPG_GOBJECT(this_ptr)), &area, &intersection)) {
        phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &intersection, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_FALSE;
    }
}


%%
add-arginfo GtkWidget translate_coordinates
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, dest_widget, GtkWidget, 0)
    ZEND_ARG_INFO(0, src_x)
    ZEND_ARG_INFO(0, src_y)
ZEND_END_ARG_INFO();

%%
override gtk_widget_translate_coordinates
PHP_METHOD
{
    gint src_x, src_y, dest_x, dest_y;
    zval *dest_widget;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Oii", &dest_widget, gtkwidget_ce, &src_x, &src_y))
        return;

    if (gtk_widget_translate_coordinates(GTK_WIDGET(PHPG_GOBJECT(this_ptr)), GTK_WIDGET(PHPG_GOBJECT(dest_widget)), src_x, src_y, &dest_x, &dest_y)) {
        php_gtk_build_value(&return_value, "(ii)", dest_x, dest_y);
    } else {
        RETURN_FALSE;
    }
}

%% }}}


%% {{{ GtkWindow
%%
override gtk_window_get_position
PHP_METHOD
{
    gint root_x, root_y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_window_get_position(GTK_WINDOW(PHPG_GOBJECT(this_ptr)), &root_x, &root_y);
    php_gtk_build_value(&return_value, "(ii)", root_x, root_y);

}

%%
override gtk_window_get_default_size
PHP_METHOD
{
    gint width, height;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_window_get_default_size(GTK_WINDOW(PHPG_GOBJECT(this_ptr)), &width, &height);
    php_gtk_build_value(&return_value, "(ii)", width, height);

}

%%
override gtk_window_get_frame_dimensions
PHP_METHOD
{
    gint left, top, right, bottom;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_window_get_frame_dimensions(GTK_WINDOW(PHPG_GOBJECT(this_ptr)), &left, &top, &right, &bottom);
    php_gtk_build_value(&return_value, "(iiii)", left, top, right, bottom);

}

%%
override gtk_window_get_size
PHP_METHOD
{
    gint width, height;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_window_get_size(GTK_WINDOW(PHPG_GOBJECT(this_ptr)), &width, &height);
    php_gtk_build_value(&return_value, "(ii)", width, height);

}
%% }}}

%% include gtktextview.overrides
%% include gtktreeview.overrides
