/* vim: set ft=cpp fdm=marker: */
%%
headers
#include "gen_atk.h"
#include "gen_gdk.h"
#include "gen_pango.h"
#include "ext/standard/file.h"

/* TODO
 * implement gtk_adjustment_set_all
 */
%% {{{ ignores [confirmed]

%%
ignore-glob
	*_ref
	*_unref
	*_get_type
	gtk_arg_*
	gtk_args_*
	gtk_check_button_new_*
	gtk_init_add_*
	gtk_marshal_*
	gtk_quit_add_*
	gtk_radio_button_new_*
	gtk_radio_tool_button_new_*
	gtk_signal_*
	gtk_timeout_add_*
	gtk_toggle_button_new_*
%%
ignore
	gtk_button_new_with_label
	gtk_button_new_with_mnemonic
	gtk_tree_view_column_set_attributes
	gtk_color_button_new
	gtk_dialog_new
	gtk_exit
	gtk_false
	gtk_init
	gtk_init_check
	gtk_list_store_newv
	gtk_list_store_set_valist
	gtk_tree_view_new
	gtk_tree_view_column_new
	gtk_true
%% }}}
	
%% {{{ ignores [tbd]
%%
ignore-glob
	gtk_idle_add_*
	gtk_target_list_*
%%
ignore
	gtk_accel_group_activate
	gtk_accel_group_add
	gtk_accel_group_attach
	gtk_accel_group_create_add
	gtk_accel_group_create_remove
	gtk_accel_group_detach
	gtk_accel_group_entries_from_object
	gtk_accel_group_get_entry
	gtk_accel_group_handle_add
	gtk_accel_group_handle_remove
	gtk_accel_group_lock
	gtk_accel_group_lock_entry
	gtk_accel_group_new
	gtk_accel_group_ref
	gtk_accel_group_remove
	gtk_accel_groups_activate
	gtk_accel_groups_from_object
	gtk_accel_group_unlock
	gtk_accel_group_unlock_entry
	gtk_accel_group_unref
	gtk_adjustment_set_all
	gtk_clist_construct
	gtk_clist_set_row_data_full
	gtk_container_add_child_arg_type
	gtk_container_addv
	gtk_container_add_with_args
	gtk_container_arg_get
	gtk_container_arg_set
	gtk_container_child_arg_get_info
	gtk_container_child_args_collect
	gtk_container_child_composite_name
	gtk_container_child_getv
	gtk_container_child_set
	gtk_container_child_setv
	gtk_container_clear_resize_widgets
	gtk_container_dequeue_resize_handler
	gtk_container_forall
	gtk_container_foreach
	gtk_container_foreach_full
	gtk_container_get_toplevels
	gtk_container_query_child_args
	gtk_container_queue_resize
	gtk_draw_box_gap
	gtk_draw_check
	gtk_draw_cross
	gtk_draw_extension
	gtk_draw_flat_box
	gtk_draw_focus
	gtk_draw_handle
	gtk_draw_option
	gtk_draw_ramp
	gtk_draw_shadow_gap
	gtk_draw_slider
	gtk_draw_tab
	gtk_file_chooser_dialog_new
	gtk_get_current_event
	gtk_get_event_widget
	gtk_idle_remove_by_data
	gtk_item_factory_create_item
	gtk_item_factory_create_items_ac
	gtk_item_factory_create_menu_entries
	gtk_item_factory_delete_entries
	gtk_item_factory_delete_entry
	gtk_item_factory_popup_data
	gtk_item_factory_popup_with_data
	gtk_item_factory_set_translate_func
	gtk_key_snooper_install
	gtk_key_snooper_remove
	gtk_label_new_with_mnemonic
	gtk_menu_attach_to_widget
	gtk_message_dialog_new_with_markup
	gtk_object_add_arg_type
	gtk_object_arg_get
	gtk_object_arg_get_info
	gtk_object_args_collect
	gtk_object_arg_set
	gtk_object_get
	gtk_object_get_data_by_id
	gtk_object_get_user_data
	gtk_object_getv
	gtk_object_new
	gtk_object_newv
	gtk_object_query_args
	gtk_object_remove_data_by_id
	gtk_object_remove_no_notify_by_id
	gtk_object_set
	gtk_object_set_data_by_id
	gtk_object_set_data_by_id_full
	gtk_object_set_data_full
	gtk_object_set_user_data
	gtk_object_setv
	gtk_object_weakref
	gtk_object_weakunref
	gtk_preview_uninit
	gtk_progress_bar_new
	gtk_progress_bar_update
	gtk_propagate_event
	gtk_quit_remove_by_data
	gtk_range_default_htrough_click
	gtk_range_default_vtrough_click
	gtk_range_trough_click
	gtk_set_locale
	gtk_signal_add_emission_hook_full
	gtk_signal_disconnect_by_data
	gtk_signal_disconnect_by_func
	gtk_signal_emit
	gtk_signal_emit_by_name
	gtk_signal_emitv
	gtk_signal_emitv_by_name
	gtk_signal_handler_block_by_data
	gtk_signal_handler_block_by_func
	gtk_signal_handler_pending_by_func
	gtk_signal_handler_unblock_by_data
	gtk_signal_handler_unblock_by_func
	gtk_signal_n_emissions
	gtk_signal_n_emissions_by_name
	gtk_signal_query
	gtk_signal_set_funcs
	gtk_text_view_new_with_buffer
	gtk_tooltips_data_get
	gtk_trace_referencing
	gtk_type_check_class_cast
	gtk_type_check_object_cast
	gtk_type_register_enum
	gtk_type_register_flags
	gtk_widget_get
	gtk_widget_getv
	gtk_widget_new
	gtk_widget_newv
	gtk_widget_reset_shapes
	gtk_widget_set
	gtk_widget_setv
	gtk_window_add_embedded_xid
	gtk_window_remove_embedded_xid
	gtk_window_reposition
%%
ignore
	GtkArgFlags
	GtkPrivateFlags
%% }}}

%% {{{ constants
%%
constants
	/* register non-enum constants */

	phpg_register_int_constant(gtk_ce, "PRIORITY_HIGH", sizeof("PRIORITY_HIGH")-1, G_PRIORITY_HIGH);
	phpg_register_int_constant(gtk_ce, "PRIORITY_DEFAULT", sizeof("PRIORITY_HIGH")-1, G_PRIORITY_HIGH);
	phpg_register_int_constant(gtk_ce, "PRIORITY_HIGH_IDLE", sizeof("PRIORITY_HIGH_IDLE")-1, G_PRIORITY_HIGH_IDLE);
	phpg_register_int_constant(gtk_ce, "PRIORITY_DEFAULT_IDLE", sizeof("PRIORITY_DEFAULT_IDLE")-1, G_PRIORITY_DEFAULT_IDLE);
	phpg_register_int_constant(gtk_ce, "PRIORITY_LOW", sizeof("PRIORITY_LOW")-1, G_PRIORITY_LOW);

	/* Fundamental GTypes */
	phpg_register_int_constant(gtk_ce, "TYPE_INVALID", sizeof("TYPE_INVALID")-1, G_TYPE_INVALID);
	phpg_register_int_constant(gtk_ce, "TYPE_NONE", sizeof("TYPE_NONE")-1, G_TYPE_NONE);
	phpg_register_int_constant(gtk_ce, "TYPE_INTERFACE", sizeof("TYPE_INTERFACE")-1, G_TYPE_INTERFACE);
	phpg_register_int_constant(gtk_ce, "TYPE_CHAR", sizeof("TYPE_CHAR")-1, G_TYPE_CHAR);
	phpg_register_int_constant(gtk_ce, "TYPE_BOOLEAN", sizeof("TYPE_BOOLEAN")-1, G_TYPE_BOOLEAN);
	phpg_register_int_constant(gtk_ce, "TYPE_LONG", sizeof("TYPE_LONG")-1, G_TYPE_LONG);
	phpg_register_int_constant(gtk_ce, "TYPE_ENUM", sizeof("TYPE_ENUM")-1, G_TYPE_ENUM);
	phpg_register_int_constant(gtk_ce, "TYPE_FLAGS", sizeof("TYPE_FLAGS")-1, G_TYPE_FLAGS);
	phpg_register_int_constant(gtk_ce, "TYPE_DOUBLE", sizeof("TYPE_DOUBLE")-1, G_TYPE_DOUBLE);
	phpg_register_int_constant(gtk_ce, "TYPE_STRING", sizeof("TYPE_STRING")-1, G_TYPE_STRING);
	phpg_register_int_constant(gtk_ce, "TYPE_POINTER", sizeof("TYPE_POINTER")-1, G_TYPE_POINTER);
	phpg_register_int_constant(gtk_ce, "TYPE_BOXED", sizeof("TYPE_BOXED")-1, G_TYPE_BOXED);
	phpg_register_int_constant(gtk_ce, "TYPE_PARAM", sizeof("TYPE_PARAM")-1, G_TYPE_PARAM);
	phpg_register_int_constant(gtk_ce, "TYPE_OBJECT", sizeof("TYPE_OBJECT")-1, G_TYPE_OBJECT);
	phpg_register_int_constant(gtk_ce, "TYPE_PHP_VALUE", sizeof("TYPE_PHP_VALUE")-1, G_TYPE_PHP_VALUE);
%% }}}

%% {{{ main loop
%%
override gtk_timeout_add

static void phpg_gtk_timeout_add_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool with_priority)
{
	guint interval;
	gint priority = G_PRIORITY_DEFAULT;
	zval *callback = NULL;
	zval *extra;
	zval *data = NULL;
	char *callback_filename;
	uint callback_lineno;
	guint handler_id;
	int req_args = with_priority ? 3 : 2;

	if (ZEND_NUM_ARGS() < req_args) {
		php_error(E_WARNING, "%s::%s() requires at least %d arguments, %d given",
				  get_active_class_name(NULL TSRMLS_CC),
				  get_active_function_name(TSRMLS_C), req_args, ZEND_NUM_ARGS());
		return;
	}

	if (with_priority) {
		if (!php_gtk_parse_args(req_args, "iiV", &interval, &priority, &callback))
			return;
	} else {
		if (!php_gtk_parse_args(req_args, "iV", &interval, &callback))
			return;
	}

	callback_filename = zend_get_executed_filename(TSRMLS_C);
	callback_lineno = zend_get_executed_lineno(TSRMLS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), req_args, ZEND_NUM_ARGS());
	if (!extra) {
		MAKE_STD_ZVAL(extra);
		array_init(extra);
	}
	php_gtk_build_value(&data, "(VNsi)", callback, extra, callback_filename, callback_lineno);

	handler_id = g_timeout_add_full(priority, interval, phpg_handler_marshal, data, phpg_destroy_notify);
	RETURN_LONG(handler_id);
}

PHP_METHOD
{
	phpg_gtk_timeout_add_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}

%%
add Gtk timeout_add_priority
PHP_METHOD
{
	phpg_gtk_timeout_add_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}

%%
override gtk_quit_add

PHP_METHOD
{
	guint main_level;
	zval *callback = NULL;
	zval *extra;
	zval *data = NULL;
	char *callback_filename;
	uint callback_lineno;
	guint handler_id;

	if (ZEND_NUM_ARGS() < 2) {
		php_error(E_WARNING, "%s::%s() requires at least 2 arguments, %d given",
				  get_active_class_name(NULL TSRMLS_CC),
				  get_active_function_name(TSRMLS_C), ZEND_NUM_ARGS());
		return;
	}

	if (!php_gtk_parse_args(2, "iV", &main_level, &callback))
		return;

	callback_filename = zend_get_executed_filename(TSRMLS_C);
	callback_lineno = zend_get_executed_lineno(TSRMLS_C);
	extra = php_gtk_func_args_as_hash(ZEND_NUM_ARGS(), 2, ZEND_NUM_ARGS());
	if (!extra) {
		MAKE_STD_ZVAL(extra);
		array_init(extra);
	}
	php_gtk_build_value(&data, "(VNsi)", callback, extra, callback_filename, callback_lineno);

	handler_id = gtk_quit_add_full(main_level, phpg_handler_marshal, NULL, data, phpg_destroy_notify);
	RETURN_LONG(handler_id);
}

%% }}}

%% {{{ functions
%%
override gtk_icon_size_lookup
PHP_METHOD
{
	gint width, height;
	zval *php_size = NULL;
	GtkIconSize size;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_size))
		return;

    if (php_size && phpg_gvalue_get_enum(GTK_TYPE_ICON_SIZE, php_size, (gint *)&size) == FAILURE) {
		return;
	}

	gtk_icon_size_lookup(size, &width, &height);

	php_gtk_build_value(&return_value, "(ii)", width, height);
}

%%
override gtk_stock_list_ids
PHP_METHOD
{
	GSList *ids;

	array_init(return_value);
	for (ids = gtk_stock_list_ids(); ids; ids = ids->next) {
		add_next_index_string(return_value, (char *) ids->data, 1);
		g_free(ids->data);
	}
	g_slist_free(ids);
}

%%
override gtk_stock_lookup
PHP_METHOD
{
	char *stock_id;
	GtkStockItem item;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &stock_id))
		return;

	if (gtk_stock_lookup(stock_id, &item)) {
		php_gtk_build_value(&return_value, "(ssiis)", item.stock_id, item.label,
							item.modifier, item.keyval, item.translation_domain);
	} else {
		return;
	}
}
%% }}}

%% {{{ GtkButton
%%
override gtk_button_new
PHP_METHOD
{
	GObject *wrapped_obj;
	gchar *text = NULL;
	zend_bool use_underline = 0;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sb", &text, &use_underline)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
	}

	if (text) {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label",
											  text, "use-underline", use_underline, NULL);
	} else {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
	}

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
	}

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_button_new_from_stock new_from_stock ZEND_ACC_PUBLIC|ZEND_ACC_STATIC
PHP_METHOD
{
	GObject *wrapped_obj;
	gchar *stock = NULL;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &stock)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
	}

	wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label", stock,
										  "use-stock", TRUE, "use-underline", TRUE, NULL);

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkButton);
	}

    phpg_gobject_new(&return_value, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkCellLayout
%%
override gtk_cell_layout_set_attributes
PHP_METHOD
{
	zval *php_cell = NULL;
	GtkCellRenderer *cell = NULL;
	GtkCellLayout *layout = NULL;
	zval ***args = NULL;
	int i, argc = ZEND_NUM_ARGS();

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(1, "O", &php_cell, gtkcellrenderer_ce))
		return;

	if ((argc-1)% 2) {
		php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
				  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
	}

	layout = GTK_CELL_LAYOUT(PHPG_GOBJECT(this_ptr));
	cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
	gtk_cell_layout_clear_attributes(layout, cell);
	args = php_gtk_func_args(argc);
	for (i = 1; i < argc; i += 2) {
		zval *attr = *args[i];
		zval *column = *args[i+1];

		if (Z_TYPE_P(attr) != IS_STRING) {
			php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
					  i, zend_zval_type_name(attr));
			efree(args);
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
		}
		if (Z_TYPE_P(column) != IS_LONG) {
			php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
					  i, zend_zval_type_name(column));
			efree(args);
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
		}

		gtk_cell_layout_add_attribute(layout, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
	}
	efree(args);
}
%% }}}

%% {{{ GtkCheckButton
%%
override gtk_check_button_new
PHP_METHOD
{
	GObject *wrapped_obj;
	gchar *text = NULL;
	zend_bool use_underline = 0;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sb", &text, &use_underline)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkCheckButton);
	}

	if (text) {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label",
											  text, "use-underline", use_underline, NULL);
	} else {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
	}

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkCheckButton);
	}

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkDialog
%%
override gtk_dialog_new_with_buttons
PHP_METHOD
{
	char *title = NULL;
	GtkWindow *parent = NULL;
	zval *php_parent = NULL, *php_flags = NULL;
	zval *buttons = NULL;
	GtkDialogFlags flags = 0;
	GObject *wrapped_obj;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sNVa", &title, &php_parent, gtkwindow_ce, &php_flags, &buttons)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
	}
	if (php_parent) {
		if (Z_TYPE_P(php_parent) == IS_NULL)
			parent = NULL;
		else
			parent = GTK_WINDOW(PHPG_GOBJECT(php_parent));
	}

	if (php_flags && phpg_gvalue_get_flags(GTK_TYPE_DIALOG_FLAGS, php_flags, (gint *)&flags) == FAILURE) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
	}

	wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
	}

	if (title) {
		gtk_window_set_title(GTK_WINDOW(wrapped_obj), title);
	}
	if (parent) {
		gtk_window_set_transient_for(GTK_WINDOW(wrapped_obj), parent);
	}
	if (flags & GTK_DIALOG_MODAL) {
		gtk_window_set_modal(GTK_WINDOW(wrapped_obj), TRUE);
	}
	if (flags & GTK_DIALOG_DESTROY_WITH_PARENT) {
		gtk_window_set_destroy_with_parent (GTK_WINDOW(wrapped_obj), TRUE);
	}
	if (flags & GTK_DIALOG_NO_SEPARATOR) {
		gtk_dialog_set_has_separator (GTK_DIALOG(wrapped_obj), FALSE);
	}

	if (buttons) {
		zval **text, **response;

		if (zend_hash_num_elements(Z_ARRVAL_P(buttons)) % 2) {
			php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
			gtk_object_destroy(GTK_OBJECT(wrapped_obj));
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
		}

		zend_hash_internal_pointer_reset(Z_ARRVAL_P(buttons));
		while (zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&text) == SUCCESS) {
			zend_hash_move_forward(Z_ARRVAL_P(buttons));
			zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&response); /* safe */
			zend_hash_move_forward(Z_ARRVAL_P(buttons));

			if (Z_TYPE_PP(text) != IS_STRING || Z_TYPE_PP(response) != IS_LONG) {
				php_error(E_WARNING, "%s::%s(): each pair in button list has to string/number",
						  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
				gtk_object_destroy(GTK_OBJECT(wrapped_obj));
				PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
			}

			gtk_dialog_add_button(GTK_DIALOG(wrapped_obj), Z_STRVAL_PP(text), Z_LVAL_PP(response));
		}
	}

	phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkIconSet
%%
override gtk_icon_set_get_sizes
PHP_METHOD
{
	GtkIconSize *sizes;
	gint n_sizes, i;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	gtk_icon_set_get_sizes((GtkIconSet *)PHPG_GBOXED(this_ptr), &sizes, &n_sizes);
	array_init(return_value);

	for (i = 0; i < n_sizes; i++) {
		add_next_index_long(return_value, sizes[i]);
	}

	g_free(sizes);
}
%% }}}

%% {{{ GtkFileChooserDialog
%%
override gtk_file_chooser_dialog_new_with_backend
PHP_METHOD
{
	char *title = NULL, *backend = NULL;
	zval *php_parent = NULL, *php_action = NULL;
	zval *buttons = NULL;
	GtkWindow *parent = NULL;
	GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
	GObject *wrapped_obj;
	int n = 0;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sNVas", &title, &php_parent,
							gtkwindow_ce, &php_action, &buttons, &backend)) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
	}

	if (php_parent) {
		if (Z_TYPE_P(php_parent) == IS_NULL)
			parent = NULL;
		else
			parent = GTK_WINDOW(PHPG_GOBJECT(php_parent));
	}

	if (php_action && phpg_gvalue_get_enum(GTK_TYPE_FILE_CHOOSER_ACTION, php_action, (gint *)&action) == FAILURE) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
	}

	if (buttons) {
		n = zend_hash_num_elements(Z_ARRVAL_P(buttons));
	}
	if (n % 2) {
		php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
				  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
	}

	wrapped_obj = (GObject *) g_object_new(phpg_gtype_from_zval(this_ptr),
										   "title", title,
										   "action", action,
										   "file-system-backend", backend, NULL);
	if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkFileChooserDialog);
	}

	if (parent) {
		gtk_window_set_transient_for(GTK_WINDOW(wrapped_obj), parent);
	}

	if (buttons) {
		zval **text, **response;

		if (zend_hash_num_elements(Z_ARRVAL_P(buttons)) % 2) {
			php_error(E_WARNING, "%s::%s(): button list has to contain pairs of items",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
			gtk_object_destroy(GTK_OBJECT(wrapped_obj));
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
		}

		zend_hash_internal_pointer_reset(Z_ARRVAL_P(buttons));
		while (zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&text) == SUCCESS) {
			zend_hash_move_forward(Z_ARRVAL_P(buttons));
			zend_hash_get_current_data(Z_ARRVAL_P(buttons), (void **)&response); /* safe */
			zend_hash_move_forward(Z_ARRVAL_P(buttons));

			if (Z_TYPE_PP(text) != IS_STRING || Z_TYPE_PP(response) != IS_LONG) {
				php_error(E_WARNING, "%s::%s(): each pair in button list has to string/number",
						  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
				gtk_object_destroy(GTK_OBJECT(wrapped_obj));
				PHPG_THROW_CONSTRUCT_EXCEPTION(GtkDialog);
			}

			gtk_dialog_add_button(GTK_DIALOG(wrapped_obj), Z_STRVAL_PP(text), Z_LVAL_PP(response));
		}
	}

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkLabel
%%
override gtk_label_new
PHP_METHOD
{
	GObject *wrapped_obj;
	gchar *text = NULL;
	zend_bool use_underline = 0;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sb", &text, &use_underline)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkLabel);
	}

	if (text) {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label", text,
											  "use-underline", use_underline, NULL);
	} else {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
	}

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkLabel);
	}

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_label_get
PHP_METHOD
{
	gchar *text = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	gtk_label_get(GTK_LABEL(PHPG_GOBJECT(this_ptr)), &text);
	if (text) {
		RETURN_STRING(text, 1);
	} else {
		RETURN_EMPTY_STRING();
	}
}
%%
override gtk_label_get_selection_bounds
PHP_METHOD
{
	gint start, end;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	gtk_label_get_selection_bounds(GTK_LABEL(PHPG_GOBJECT(this_ptr)), &start, &end);
	php_gtk_build_value(&return_value, "(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets
PHP_METHOD
{
	gint x, y;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	gtk_label_get_layout_offsets(GTK_LABEL(PHPG_GOBJECT(this_ptr)), &x, &y);
	php_gtk_build_value(&return_value, "(ii)", x, y);
}
%% }}}

%% {{{ GtkListStore
%%
override gtk_list_store_new
PHP_METHOD
{
	zval ***args;
	GType *column_types;
	GObject *wrapped_obj;
	int i, argc = ZEND_NUM_ARGS();

	if (argc == 0) {
		php_error(E_WARNING, "%s::%s() requires at least 1 argument",
				  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
	}

	args = php_gtk_func_args(argc);

	column_types = emalloc(argc * sizeof(GType));
	for (i = 0; i < argc; i++) {
		column_types[i] = phpg_gtype_from_zval(*args[i]);
		if (column_types[i] == 0) {
			efree(column_types);
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
		}
	}
	
	wrapped_obj = g_object_newv(phpg_gtype_from_zval(this_ptr), 0, NULL);
	gtk_list_store_set_column_types(GTK_LIST_STORE(wrapped_obj), argc, column_types);
	efree(column_types);
	efree(args);
	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
	}

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_list_store_append
PHP_METHOD
{
	GtkTreeIter iter;
	zval *items = NULL;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|a", &items))
		return;

	gtk_list_store_append(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), &iter);

	/* TODO optionally set items */

	phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
override gtk_list_store_set
PHP_METHOD
{
	zval ***items;
	zval *php_iter;
	GtkTreeIter *iter = NULL;
	GtkTreeModel *model;
	int i, argc = ZEND_NUM_ARGS();

	NOT_STATIC_METHOD();

	if (argc < 3) {
		php_error(E_WARNING, "%s::%s() requires at least 3 arguments, %d given",
				  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), argc);
		return;
	}

	if (!php_gtk_parse_args(1, "O", &php_iter, gtktreeiter_ce))
		return;

	iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

	if ((argc-1) % 2) {
		php_error(E_WARNING, "%s::%s() requires arguments 2-n to be column/value pairs",
				  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
		return;
	}

	model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
	items = php_gtk_func_args(argc);
	for (i = 1; i < argc; i += 2) {
		zval *zcolumn = *items[i];
		zval *zvalue = *items[i+1];
		gint column;
		GValue value = { 0 };
		
		if (Z_TYPE_P(zcolumn) != IS_LONG) {
			php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
					  i, zend_zval_type_name(zcolumn));
			efree(items);
			return;
		}

		column = Z_LVAL_P(zcolumn);
		if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
			php_error(E_WARNING, "%s::%s(): argument %d is out of range - model has %d column(s)",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
					  i, gtk_tree_model_get_n_columns(model));
			efree(items);
			return;
		}

		g_value_init(&value, gtk_tree_model_get_column_type(model, column));

		if (phpg_gvalue_from_zval(&value, zvalue TSRMLS_CC) == FAILURE) {
			php_error(E_WARNING, "%s::%s(): argument %d is of the wrong type for column %d",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
					  i+1, column);
			efree(items);
			return;
		}

		gtk_list_store_set_value(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), iter, column, &value);

		g_value_unset(&value);
	}

	efree(items);
}
%% }}}

%% {{{ GtkMessageDialog
%%
override gtk_message_dialog_new
PHP_METHOD
{
	GtkWindow *parent = NULL;
	zval *php_parent = NULL, *php_flags = NULL, *php_type = NULL, *php_buttons = NULL;
	GtkDialogFlags flags = 0;
	GtkMessageType type = GTK_MESSAGE_INFO;
	GtkButtonsType buttons = GTK_BUTTONS_NONE;
	char *message = NULL;
	GObject *wrapped_obj;

	if (phpg_gtype_from_zval(this_ptr) != GTK_TYPE_MESSAGE_DIALOG) {
		PHPG_THROW_EXCEPTION(phpg_construct_exception, "Subclassing GtkMessageDialog requires more than you know");
		return;
	}

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|NVVVs", &php_parent, gtkwindow_ce, &php_flags, &php_type, &php_buttons, &message)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
	}

	if (php_parent) {
		if (Z_TYPE_P(php_parent) == IS_NULL)
			parent = NULL;
		else
			parent = GTK_WINDOW(PHPG_GOBJECT(php_parent));
	}

	if (php_flags && phpg_gvalue_get_flags(GTK_TYPE_DIALOG_FLAGS, php_flags, (gint *)&flags) == FAILURE) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
	}

	if (php_type && phpg_gvalue_get_enum(GTK_TYPE_MESSAGE_TYPE, php_type, (gint *)&type) == FAILURE) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
	}

	if (php_buttons && phpg_gvalue_get_enum(GTK_TYPE_BUTTONS_TYPE, php_buttons, (gint *)&buttons) == FAILURE) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
	}

	if (!message) {
		message = "";
	}

	wrapped_obj = (GObject *) gtk_message_dialog_new(parent, flags, type, buttons, "%s", message);
	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkMessageDialog);
	}

	phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkRadioButton
%%
override gtk_radio_button_new
PHP_METHOD
{
	zval *php_group = NULL;
	char *label = NULL;
	zend_bool use_underline = 0;
	GtkRadioButton *group = NULL;
	GObject *wrapped_obj;
	GType gtype = phpg_gtype_from_zval(this_ptr);

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Nsb", &php_group, gtkradiobutton_ce, &label, &use_underline)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioButton);
	}

	if (php_group && Z_TYPE_P(php_group) != NULL) {
		group = GTK_RADIO_BUTTON(PHPG_GOBJECT(php_group));
	}

	if (group) {
		if (label) {
			wrapped_obj = (GObject *) g_object_new(gtype, "group", group, "label", label,
												   "use-underline", use_underline, NULL);
		} else {
			wrapped_obj = (GObject *) g_object_new(gtype, "group", group, NULL);
		}
	} else {
		if (label) {
			wrapped_obj = (GObject *) g_object_new(gtype, "label", label, "use-underline",
												   use_underline, NULL);
		} else {
			wrapped_obj = (GObject *) g_object_new(gtype, NULL);
		}
	}

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioButton);
	}
	phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%% }}}

%% {{{ GtkRadioToolButton
%%
override gtk_radio_tool_button_new

PHP_METHOD
{
	zval *php_group = NULL;
	GtkRadioToolButton *group = NULL;
	char *stock_id = NULL;
	GObject *wrapped_obj;
	GType gtype = phpg_gtype_from_zval(this_ptr);

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Ns", &php_group, gtkradiotoolbutton_ce, &stock_id)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioToolButton);
	}

	if (php_group && Z_TYPE_P(php_group) != NULL) {
		group = GTK_RADIO_TOOL_BUTTON(PHPG_GOBJECT(php_group));
	}

	if (group) {
		if (stock_id) {
			wrapped_obj = (GObject *) g_object_new(gtype, "group", group, "stock_id", stock_id, NULL);
		} else {
			wrapped_obj = (GObject *) g_object_new(gtype, "group", group, NULL);
		}
	} else {
		if (stock_id) {
			wrapped_obj = (GObject *) g_object_new(gtype, "stock_id", stock_id, NULL);
		} else {
			wrapped_obj = (GObject *) g_object_new(gtype, NULL);
		}
	}

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkRadioToolButton);
	}
	phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkStyle [included]
%% include gtkstyle.overrides
%% }}}

%% {{{ GtkTextAttributes

%%
override-prop GtkTextAttributes bg_color
PHPG_PROP_READER
{
	GdkColor php_retval;

	php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.bg_color;
	phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &php_retval, TRUE, TRUE TSRMLS_CC);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes fg_color
PHPG_PROP_READER
{
	GdkColor php_retval;

	php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.fg_color;
	phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &php_retval, TRUE, TRUE TSRMLS_CC);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes bg_stipple
PHPG_PROP_READER
{
	GdkBitmap *php_retval;

	php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.bg_stipple;
	phpg_gobject_new(&return_value, (GObject *)php_retval TSRMLS_CC);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes fg_stipple
PHPG_PROP_READER
{
	GdkBitmap *php_retval;

	php_retval = ((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.fg_stipple;
	phpg_gobject_new(&return_value, (GObject *)php_retval TSRMLS_CC);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes rise
PHPG_PROP_READER
{
	RETVAL_LONG(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.rise);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes underline
PHPG_PROP_READER
{
	RETVAL_LONG(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.underline);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes strikethrough
PHPG_PROP_READER
{
	RETVAL_LONG(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.strikethrough);

	return SUCCESS;
}

%%
override-prop GtkTextAttributes draw_bg
PHPG_PROP_READER
{
	RETVAL_BOOL(((GtkTextAttributes *)((phpg_gboxed_t *)object)->boxed)->appearance.draw_bg);

	return SUCCESS;
}
%% }}}

%% {{{ GtkToggleButton
%%
override gtk_toggle_button_new
PHP_METHOD
{
	GObject *wrapped_obj;
	gchar *text = NULL;
	zend_bool use_underline = 0;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sb", &text, &use_underline)) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkToggleButton);
	}

	if (text) {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), "label",
											  text, "use-underline", use_underline, NULL);
	} else {
		wrapped_obj = (GObject *)g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
	}

	if (!wrapped_obj) {
		PHPG_THROW_CONSTRUCT_EXCEPTION(GtkToggleButton);
	}

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}
%% }}}

%% {{{ GtkTreeModel

%%
override gtk_tree_model_get_iter_first
PHP_METHOD
{
	GtkTreeIter iter;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
		return;

	if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter)) {
		phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
	}
}

%%
override gtk_tree_model_get_value
PHP_METHOD
{
	zval *php_iter;
	GtkTreeIter *iter;
	GtkTreeModel *model;
	gint column;
	GValue value = { 0 };

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Oi", &php_iter, gtktreeiter_ce, &column))
		return;

	model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
	iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

	if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
		php_error(E_WARNING, "%s::%s(): column  is out of range - model has %d column(s)",
				  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
				  gtk_tree_model_get_n_columns(model));
		return;
	}

	gtk_tree_model_get_value(model, iter, column, &value);
	phpg_gvalue_to_zval(&value, &return_value, TRUE TSRMLS_CC);
}

%% }}}

%% {{{ GtkTreeViewColumn
%%
override gtk_tree_view_column_new_with_attributes
PHP_METHOD
{
	char *title = NULL;
	zval *php_cell = NULL;
	GtkCellRenderer *cell = NULL;
	GtkTreeViewColumn *tvc = NULL;
	zval ***args = NULL;
	int i, argc = ZEND_NUM_ARGS();

	if (argc <= 2) {
		if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sN", &title, &php_cell, gtkcellrenderer_ce)) {
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
		}
	} else {
		if (!php_gtk_parse_args(2, "|sN", &title, &php_cell, gtkcellrenderer_ce)) {
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
		}
	}

	tvc = GTK_TREE_VIEW_COLUMN(g_object_new(phpg_gtype_from_zval(this_ptr), NULL));
	if (php_cell && Z_TYPE_P(php_cell) != IS_NULL) {
		cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
	}

	if (title)
		gtk_tree_view_column_set_title(tvc, title);
	if (cell)
		gtk_tree_view_column_pack_start(tvc, cell, TRUE);

	if (argc > 2) {
		if (argc % 2) {
			php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
					  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
			PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
		}

		args = php_gtk_func_args(argc);
		for (i = 2; i < argc; i += 2) {
			zval *attr = *args[i];
			zval *column = *args[i+1];

			if (Z_TYPE_P(attr) != IS_STRING) {
				php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
						  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
						  i, zend_zval_type_name(attr));
				efree(args);
				PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
			}
			if (Z_TYPE_P(column) != IS_LONG) {
				php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
						  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
						  i, zend_zval_type_name(column));
				efree(args);
				PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
			}

			gtk_tree_view_column_add_attribute(tvc, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
		}
		efree(args);
	}

	phpg_gobject_set_wrapper(this_ptr, (GObject *)tvc);
}
%% }}}

%% {{{ GtkWidget
%%
override gtk_widget_intersect
PHP_METHOD
{
	zval *php_area;
	GdkRectangle area, intersection;
	
	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_area))
		return;

    if (phpg_rectangle_from_zval(php_area, &area) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects area argument to be either a 4-element array or a GdkRectangle object", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
		return;
    }
	if (gtk_widget_intersect(GTK_WIDGET(PHPG_GOBJECT(this_ptr)), &area, &intersection)) {
		phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &intersection, TRUE, TRUE TSRMLS_CC);
	} else {
		RETURN_FALSE;
	}
}

%% }}}

