/* vim: set ft=cpp fdm=marker et: */

%%
headers

static void phpg_cell_data_func_marshal(GtkCellLayout *cell_layout, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data);


%% {{{ ignores
%%
ignore
    gtk_tree_view_column_set_attributes
    gtk_list_store_newv
    gtk_list_store_set_valist
    gtk_tree_view_new
    gtk_tree_view_column_new
%% }}}

%% {{{ GtkCellLayout
%%
override gtk_cell_layout_set_attributes
PHP_METHOD
{
    zval *php_cell = NULL;
    GtkCellRenderer *cell = NULL;
    GtkCellLayout *layout = NULL;
    zval ***args = NULL;
    int i, argc = ZEND_NUM_ARGS();

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(1, "O", &php_cell, gtkcellrenderer_ce))
        return;

    if ((argc-1)% 2) {
        php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
    }

    layout = GTK_CELL_LAYOUT(PHPG_GOBJECT(this_ptr));
    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
    gtk_cell_layout_clear_attributes(layout, cell);
    args = php_gtk_func_args(argc);
    for (i = 1; i < argc; i += 2) {
        zval *attr = *args[i];
        zval *column = *args[i+1];

        if (Z_TYPE_P(attr) != IS_STRING) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(attr));
            efree(args);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
        if (Z_TYPE_P(column) != IS_LONG) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(column));
            efree(args);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }

        gtk_cell_layout_add_attribute(layout, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
    }
    efree(args);
}
%% }}}

%% {{{ GtkListStore
%%
override gtk_list_store_new
PHP_METHOD
{
    zval ***args;
    GType *column_types;
    GObject *wrapped_obj;
    int i, argc = ZEND_NUM_ARGS();

    if (argc == 0) {
        php_error(E_WARNING, "%s::%s() requires at least 1 argument",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
    }

    args = php_gtk_func_args(argc);

    column_types = emalloc(argc * sizeof(GType));
    for (i = 0; i < argc; i++) {
        column_types[i] = phpg_gtype_from_zval(*args[i]);
        if (column_types[i] == 0) {
            efree(column_types);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
        }
    }
    
    wrapped_obj = g_object_newv(phpg_gtype_from_zval(this_ptr), 0, NULL);
    gtk_list_store_set_column_types(GTK_LIST_STORE(wrapped_obj), argc, column_types);
    efree(column_types);
    efree(args);
    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_list_store_append
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|a", &items))
        return;

    gtk_list_store_append(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), &iter);

    /* TODO optionally set items */

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
override gtk_list_store_set
PHP_METHOD
{
    zval ***items;
    zval *php_iter;
    GtkTreeIter *iter = NULL;
    GtkTreeModel *model;
    int i, argc = ZEND_NUM_ARGS();

    NOT_STATIC_METHOD();

    if (argc < 3) {
        php_error(E_WARNING, "%s::%s() requires at least 3 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), argc);
        return;
    }

    if (!php_gtk_parse_args(1, "O", &php_iter, gtktreeiter_ce))
        return;

    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    if ((argc-1) % 2) {
        php_error(E_WARNING, "%s::%s() requires arguments 2-n to be column/value pairs",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    items = php_gtk_func_args(argc);
    for (i = 1; i < argc; i += 2) {
        zval *zcolumn = *items[i];
        zval *zvalue = *items[i+1];
        gint column;
        GValue value = { 0 };
        
        if (Z_TYPE_P(zcolumn) != IS_LONG) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(zcolumn));
            efree(items);
            return;
        }

        column = Z_LVAL_P(zcolumn);
        if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
            php_error(E_WARNING, "%s::%s(): argument %d is out of range - model has %d column(s)",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, gtk_tree_model_get_n_columns(model));
            efree(items);
            return;
        }

        g_value_init(&value, gtk_tree_model_get_column_type(model, column));

        if (phpg_gvalue_from_zval(&value, zvalue TSRMLS_CC) == FAILURE) {
            php_error(E_WARNING, "%s::%s(): argument %d is of the wrong type for column %d",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i+1, column);
            efree(items);
            return;
        }

        gtk_list_store_set_value(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), iter, column, &value);

        g_value_unset(&value);
    }

    efree(items);
}
%% }}}

%% {{{ GtkTreeModel

%%
override gtk_tree_model_get_iter_first
PHP_METHOD
{
    GtkTreeIter iter;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    }
}

%%
override gtk_tree_model_get_value
PHP_METHOD
{
    zval *php_iter;
    GtkTreeIter *iter;
    GtkTreeModel *model;
    gint column;
    GValue value = { 0 };

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Oi", &php_iter, gtktreeiter_ce, &column))
        return;

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
        php_error(E_WARNING, "%s::%s(): column  is out of range - model has %d column(s)",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                  gtk_tree_model_get_n_columns(model));
        return;
    }

    gtk_tree_model_get_value(model, iter, column, &value);
    phpg_gvalue_to_zval(&value, &return_value, TRUE TSRMLS_CC);
    g_value_unset(&value);
}

%% }}}

%% {{{ GtkTreeView

%%
override gtk_tree_view_insert_column_with_data_func

static void phpg_cell_data_func_marshal(GtkCellLayout *cell_layout, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_cell_layout = NULL, *php_renderer = NULL, *php_model = NULL, *php_iter = NULL;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return;
    }

    phpg_gobject_new(&php_cell_layout, (GObject*)cell_layout TSRMLS_CC);
    phpg_gobject_new(&php_renderer,    (GObject*)renderer    TSRMLS_CC);
    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, iter, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 4, &n_args);
    args[0] = &php_cell_layout;
    args[1] = &php_renderer;
    args[2] = &php_model;
    args[3] = &php_iter;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_cell_layout);
    zval_ptr_dtor(&php_renderer);
    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_iter);

    if (retval) {
        zval_ptr_dtor(&retval);
    }

    efree(callback_name);
    efree(args);
}

PHP_METHOD
{
    gint position;
    char *title;
    zval *php_cell;
    GtkCellRenderer *cell;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 4, &extra, "isOV", &position, &title, &php_cell, gtkcellrenderer_ce, &callback))
        return;

    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra);

    RETURN_LONG(gtk_tree_view_insert_column_with_data_func(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)),
                                                           position, title, cell,
                                                           (GtkTreeCellDataFunc)phpg_cell_data_func_marshal,
                                                           cb_data, phpg_cb_data_destroy));
}

%% }}}

%% {{{ GtkTreeViewColumn
%%
override gtk_tree_view_column_new_with_attributes
PHP_METHOD
{
    char *title = NULL;
    zval *php_cell = NULL;
    GtkCellRenderer *cell = NULL;
    GtkTreeViewColumn *tvc = NULL;
    zval ***args = NULL;
    int i, argc = ZEND_NUM_ARGS();

    if (argc <= 2) {
        if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sN", &title, &php_cell, gtkcellrenderer_ce)) {
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
    } else {
        if (!php_gtk_parse_args(2, "|sN", &title, &php_cell, gtkcellrenderer_ce)) {
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
    }

    tvc = GTK_TREE_VIEW_COLUMN(g_object_new(phpg_gtype_from_zval(this_ptr), NULL));
    if (php_cell && Z_TYPE_P(php_cell) != IS_NULL) {
        cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
    }

    if (title)
        gtk_tree_view_column_set_title(tvc, title);
    if (cell)
        gtk_tree_view_column_pack_start(tvc, cell, TRUE);

    if (argc > 2) {
        if (argc % 2) {
            php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }

        args = php_gtk_func_args(argc);
        for (i = 2; i < argc; i += 2) {
            zval *attr = *args[i];
            zval *column = *args[i+1];

            if (Z_TYPE_P(attr) != IS_STRING) {
                php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                          i, zend_zval_type_name(attr));
                efree(args);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
            }
            if (Z_TYPE_P(column) != IS_LONG) {
                php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                          i, zend_zval_type_name(column));
                efree(args);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
            }

            gtk_tree_view_column_add_attribute(tvc, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
        }
        efree(args);
    }

    phpg_gobject_set_wrapper(this_ptr, (GObject *)tvc);
}

%%
override gtk_tree_view_column_set_cell_data_func
PHP_METHOD
{
    zval *php_cell;
    GtkCellRenderer *cell;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 2, &extra, "OV", &php_cell, gtkcellrenderer_ce, &callback))
        return;

    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra);

    gtk_tree_view_column_set_cell_data_func(GTK_TREE_VIEW_COLUMN(PHPG_GOBJECT(this_ptr)), cell,
                                            (GtkTreeCellDataFunc)phpg_cell_data_func_marshal,
                                            cb_data, phpg_cb_data_destroy);
}
%% }}}
