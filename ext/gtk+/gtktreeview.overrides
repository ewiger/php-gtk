/* vim: set ft=cpp fdm=marker et: */

%%
headers

#include "zend_interfaces.h"

static void phpg_cell_data_func_marshal(GtkCellLayout *cell_layout, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data);
static void phpg_store_set_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool is_tree);
static zval* phpg_gtktreemodel_read_dimension_handler(zval *object, zval *offset, int type TSRMLS_DC);
static int phpg_gtktreemodel_has_dimension_handler(zval *object, zval *offset, int check_empty TSRMLS_DC);
static void phpg_gtktreemodel_write_dimension_handler(zval *object, zval *offset, zval *value TSRMLS_DC);
static int phpg_gtktreemodel_count_elements_handler(zval *object, long *count TSRMLS_DC);
static gint phpg_tree_iter_compare_func_marshal(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);
static gboolean phpg_tree_model_filter_visible_func_marshal(GtkTreeModel *model, GtkTreeIter *iter, gpointer data);
static gboolean phpg_tree_view_row_separator_func_marshal (GtkTreeModel *model, GtkTreeIter *iter, gpointer data);

%%
post-registration GtkListStore

    gtkliststore_ce->get_iterator = phpg_treemodel_get_iterator;
    zend_class_implements(gtkliststore_ce TSRMLS_CC, 1, zend_ce_traversable);

%%
post-registration GtkTreeStore

    gtktreestore_ce->get_iterator = phpg_treemodel_get_iterator;
    zend_class_implements(gtktreestore_ce TSRMLS_CC, 1, zend_ce_traversable);


%% {{{ ignores
%%
ignore-glob
    gtk_tree_path_*
%%
ignore
    gtk_cell_renderer_get_size
    gtk_list_store_newv
    gtk_list_store_set_valist
    gtk_tree_model_get_valist
    gtk_tree_model_filter_set_visible_func
    gtk_tree_row_reference_new_proxy
    gtk_tree_row_reference_inserted
    gtk_tree_row_reference_deleted
    gtk_tree_row_reference_reordered
    gtk_tree_store_newv
    gtk_tree_store_set_valist
    gtk_tree_view_new
    gtk_tree_view_column_new
    gtk_tree_view_column_set_attributes
    gtk_tree_view_column_set_cell_data_func
%% }}}

%% {{{ GtkCellLayout
%%
add-arginfo GtkCellLayout set_attributes
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, cell)
    ZEND_ARG_INFO(0, attribute)
    ZEND_ARG_INFO(0, column)
ZEND_END_ARG_INFO();

%%
override gtk_cell_layout_set_attributes
PHP_METHOD
{
    zval *php_cell = NULL;
    GtkCellRenderer *cell = NULL;
    GtkCellLayout *layout = NULL;
    zval ***args = NULL;
    int i, argc = ZEND_NUM_ARGS();

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(1, "O", &php_cell, gtkcellrenderer_ce))
        return;

    if ((argc-1)% 2) {
        php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
    }

    layout = GTK_CELL_LAYOUT(PHPG_GOBJECT(this_ptr));
    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
    gtk_cell_layout_clear_attributes(layout, cell);
    args = php_gtk_func_args(argc);
    for (i = 1; i < argc; i += 2) {
        zval *attr = *args[i];
        zval *column = *args[i+1];

        if (Z_TYPE_P(attr) != IS_STRING) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(attr));
            efree(args);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
        if (Z_TYPE_P(column) != IS_LONG) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(column));
            efree(args);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }

        gtk_cell_layout_add_attribute(layout, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
    }
    efree(args);
}

%%
add-arginfo GtkCellLayout set_cell_data_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, cellrenderer, GtkCellRenderer, 1)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_cell_layout_set_cell_data_func
PHP_METHOD
{
    zval *php_cell;
    GtkCellRenderer *cell;
    GtkCellLayout *layout = NULL;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 2, &extra, "OV", &php_cell, gtkcellrenderer_ce, &callback))
        return;

    layout = GTK_CELL_LAYOUT(PHPG_GOBJECT(this_ptr));
    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    gtk_cell_layout_set_cell_data_func(layout, cell, (GtkCellLayoutDataFunc)phpg_cell_data_func_marshal,
                                       cb_data, phpg_cb_data_destroy);
}
%% }}}

%% {{{ GtkCellRenderer
%%
override gtk_cell_renderer_get_fixed_size
PHP_METHOD
{
    int width, height = 0;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(PHPG_GOBJECT(this_ptr)), &width, &height);
    php_gtk_build_value(&return_value, "(ii)", width, height);
}

%% }}}

%% {{{ GtkCellView

%%
override gtk_cell_view_get_cell_renderers
PHP_METHOD
{
    GList *list, *item;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    list = gtk_cell_view_get_cell_renderers(GTK_CELL_VIEW(PHPG_GOBJECT(this_ptr)));

    array_init(return_value);
    for (item = list; item; item = item->next) {
        zval *php_item = NULL;
        phpg_gobject_new(&php_item, G_OBJECT(item->data) TSRMLS_CC);
        add_next_index_zval(return_value, php_item);
    }

    g_list_free(list);
}

%% }}}

%% {{{ GtkListStore
%%
add-arginfo GtkListStore __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, type_col_0)
    ZEND_ARG_INFO(0, type_col_1)
    ZEND_ARG_INFO(0, ...)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_new
PHP_METHOD
{
    zval ***args;
    GType *column_types;
    GObject *wrapped_obj;
    int i, argc = ZEND_NUM_ARGS();

    if (argc > 0) {
        args = php_gtk_func_args(argc);
        column_types = emalloc(argc * sizeof(GType));

        for (i = 0; i < argc; i++) {
            column_types[i] = phpg_gtype_from_zval(*args[i]);
            if (column_types[i] == 0) {
                efree(column_types);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
            }
        }

        wrapped_obj = g_object_newv(phpg_gtype_from_zval(this_ptr), 0, NULL);
        gtk_list_store_set_column_types(GTK_LIST_STORE(wrapped_obj), argc, column_types);

        efree(column_types);
        efree(args);
    } else {
        wrapped_obj = g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_list_store_set_column_types
PHP_METHOD
{
    zval *php_types, **item;
    GType *column_types;
    int i, n;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &php_types)) {
        return;
    }
    
    n = zend_hash_num_elements(Z_ARRVAL_P(php_types));

    if (n == 0) {
        php_error(E_WARNING, "number of columns has to be > 0");
        return;
    }

    column_types = safe_emalloc(n, sizeof(GType), 0);
    for (i = 0, zend_hash_internal_pointer_reset(Z_ARRVAL_P(php_types));
         zend_hash_get_current_data(Z_ARRVAL_P(php_types), (void**)&item) == SUCCESS;
         zend_hash_move_forward(Z_ARRVAL_P(php_types)), i++) {

        column_types[i] = phpg_gtype_from_zval(*item);
        if (column_types[i] == 0) {
            efree(column_types);
            php_error(E_WARNING, "could not set column types for GtkListStore");
            return;
        }
    }

    gtk_list_store_set_column_types(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), i, column_types);

    efree(column_types);
}

%%
add-arginfo GtkListStore append
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_append
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|a", &items))
        return;

    gtk_list_store_append(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), &iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items TSRMLS_CC) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
add-arginfo GtkListStore prepend
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_prepend
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|a", &items))
        return;

    gtk_list_store_prepend(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), &iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items TSRMLS_CC) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
add-arginfo GtkListStore insert
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, position)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();


%%
override gtk_list_store_insert
PHP_METHOD
{
    GtkTreeIter iter;
    GtkTreeModel *model;
    gint position;
    zval *items = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i|a", &position, &items))
        return;

    if (position < 0) {
        php_error(E_WARNING, "%s::%s() requires argument 1 to be greater than zero, %d given",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), position);
        return;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));

    if (items) {
        gint n_cols, i;
        gint *columns;
        GValue *values;
        zval **item;

        n_cols = gtk_tree_model_get_n_columns(model);
        if (zend_hash_num_elements(Z_ARRVAL_P(items)) != n_cols) {
            php_error(E_WARNING, "Cannot set row: number of row elements does not match the model");
            return;
        }

        columns = ecalloc(n_cols, sizeof(gint));
        values  = ecalloc(n_cols, sizeof(GValue));

        for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(items)), i = 0;
             zend_hash_get_current_data(Z_ARRVAL_P(items), (void **)&item) == SUCCESS;
             zend_hash_move_forward(Z_ARRVAL_P(items)), i++) {

            g_value_init(&values[i], gtk_tree_model_get_column_type(model, i));

            if (phpg_gvalue_from_zval(&values[i], *item, TRUE TSRMLS_CC) == FAILURE) {
                php_error(E_WARNING, "Cannot set row: type of element %d does not match the model", i);
                for ( ; i >= 0; i--) {
                    g_value_unset(&values[i]);
                }
                efree(columns);
                efree(values);
                return;
            }
            columns[i] = i;
        }

        gtk_list_store_insert_with_valuesv(GTK_LIST_STORE(model), &iter, position,
                                           columns, values, n_cols);

        for (i = 0; i < n_cols; i++) {
            g_value_unset(&values[i]);
        }
        efree(columns);
        efree(values);
    } else {
        gtk_list_store_insert(GTK_LIST_STORE(model), &iter, position);
    }

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}
%%
add-arginfo GtkListStore set
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 3)
    ZEND_ARG_OBJ_INFO(0, iter, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, column)
    ZEND_ARG_INFO(0, value)
    ZEND_ARG_INFO(0, column)
    ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_set
static void phpg_store_set_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool is_tree)
{
    zval ***items;
    zval *php_iter;
    GtkTreeIter *iter = NULL;
    GtkTreeModel *model;
    int i, argc = ZEND_NUM_ARGS();

    NOT_STATIC_METHOD();

    if (argc < 3) {
        php_error(E_WARNING, "%s::%s() requires at least 3 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), argc);
        return;
    }

    if (!php_gtk_parse_args(1, "O", &php_iter, gtktreeiter_ce))
        return;

    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    if ((argc-1) % 2) {
        php_error(E_WARNING, "%s::%s() requires arguments 2-n to be column/value pairs",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    items = php_gtk_func_args(argc);
    for (i = 1; i < argc; i += 2) {
        zval *zcolumn = *items[i];
        zval *zvalue = *items[i+1];
        gint column;
        GValue value = { 0 };
        
        if (Z_TYPE_P(zcolumn) != IS_LONG) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(zcolumn));
            efree(items);
            return;
        }

        column = Z_LVAL_P(zcolumn);
        if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
            php_error(E_WARNING, "%s::%s(): argument %d is out of range - model has %d column(s)",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, gtk_tree_model_get_n_columns(model));
            efree(items);
            return;
        }

        g_value_init(&value, gtk_tree_model_get_column_type(model, column));

        if (phpg_gvalue_from_zval(&value, zvalue, TRUE TSRMLS_CC) == FAILURE) {
            php_error(E_WARNING, "%s::%s(): argument %d is of the wrong type for column %d",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i+1, column);
            efree(items);
            return;
        }

        if (is_tree) {
            gtk_tree_store_set_value(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), iter, column, &value);
        } else {
            gtk_list_store_set_value(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), iter, column, &value);
        }

        g_value_unset(&value);
    }

    efree(items);
}

PHP_METHOD
{
    phpg_store_set_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, FALSE);
}

%%
override-handler GtkListStore count_elements
static int phpg_gtkliststore_count_elements_handler(zval *object, long *count TSRMLS_DC)
{
    return phpg_gtktreemodel_count_elements_handler(object, count TSRMLS_CC);
}

%%
override-handler GtkListStore has_dimension
static int phpg_gtkliststore_has_dimension_handler(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
    return phpg_gtktreemodel_has_dimension_handler(object, offset, check_empty TSRMLS_CC);
}

%%
override-handler GtkListStore read_dimension
static zval* phpg_gtkliststore_read_dimension_handler(zval *object, zval *offset, int type TSRMLS_DC)
{
    return phpg_gtktreemodel_read_dimension_handler(object, offset, type TSRMLS_CC);
}

%%
override-handler GtkListStore write_dimension
static void phpg_gtkliststore_write_dimension_handler(zval *object, zval *offset, zval *value TSRMLS_DC)
{
    phpg_gtktreemodel_write_dimension_handler(object, offset, value TSRMLS_CC);
}

%%
override-handler GtkListStore unset_dimension
static void phpg_gtkliststore_unset_dimension_handler(zval *object, zval *offset TSRMLS_DC)
{
    phpg_gtktreemodel_write_dimension_handler(object, offset, NULL TSRMLS_CC);
}

%% }}}

%% {{{ GtkTreeStore
%%
add-arginfo GtkTreeStore __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, type_col_0)
    ZEND_ARG_INFO(0, type_col_1)
    ZEND_ARG_INFO(0, ...)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_new
PHP_METHOD
{
    zval ***args;
    GType *column_types;
    GObject *wrapped_obj;
    int i, argc = ZEND_NUM_ARGS();

    if (argc > 0) {
        args = php_gtk_func_args(argc);
        column_types = emalloc(argc * sizeof(GType));

        for (i = 0; i < argc; i++) {
            column_types[i] = phpg_gtype_from_zval(*args[i]);
            if (column_types[i] == 0) {
                efree(column_types);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeStore);
            }
        }

        wrapped_obj = g_object_newv(phpg_gtype_from_zval(this_ptr), 0, NULL);
        gtk_tree_store_set_column_types(GTK_TREE_STORE(wrapped_obj), argc, column_types);

        efree(column_types);
        efree(args);
    } else {
        wrapped_obj = g_object_new(phpg_gtype_from_zval(this_ptr), NULL);
    }

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeStore);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
override gtk_tree_store_set_column_types
PHP_METHOD
{
    zval *php_types, **item;
    GType *column_types;
    int i, n;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "a", &php_types)) {
        return;
    }
    
    n = zend_hash_num_elements(Z_ARRVAL_P(php_types));

    if (n == 0) {
        php_error(E_WARNING, "number of columns has to be > 0");
        return;
    }

    column_types = safe_emalloc(n, sizeof(GType), 0);
    for (i = 0, zend_hash_internal_pointer_reset(Z_ARRVAL_P(php_types));
         zend_hash_get_current_data(Z_ARRVAL_P(php_types), (void**)&item) == SUCCESS;
         zend_hash_move_forward(Z_ARRVAL_P(php_types)), i++) {

        column_types[i] = phpg_gtype_from_zval(*item);
        if (column_types[i] == 0) {
            efree(column_types);
            php_error(E_WARNING, "could not set column types for GtkTreeStore");
            return;
        }
    }

    gtk_tree_store_set_column_types(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), i, column_types);

    efree(column_types);
}

%%
add-arginfo GtkTreeStore append
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, iter, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_append
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;
    zval *php_parent_iter = NULL;
    GtkTreeIter *parent_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Na", &php_parent_iter, gtktreeiter_ce, &items))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }

    gtk_tree_store_append(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), &iter, parent_iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items TSRMLS_CC) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}


%%
add-arginfo GtkTreeStore insert
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, position)
    ZEND_ARG_OBJ_INFO(0, parent, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_insert
PHP_METHOD
{
    GtkTreeIter iter;
    gint position;
    zval *items = NULL;
    zval *php_parent_iter = NULL;
    GtkTreeIter *parent_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i|Na", &position, &php_parent_iter, gtktreeiter_ce, &items))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }

    gtk_tree_store_insert(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), &iter, parent_iter, position);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items TSRMLS_CC) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}


%%
add-arginfo GtkTreeStore insert_before
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, parent, GtkTreeIter, 1)
    ZEND_ARG_OBJ_INFO(0, sibling, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_insert_before
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;
    zval *php_parent_iter = NULL, *php_sibling_iter = NULL;
    GtkTreeIter *parent_iter = NULL, *sibling_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|NNa", &php_sibling_iter, gtktreeiter_ce, &php_parent_iter, gtktreeiter_ce, &items))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }
    if (php_sibling_iter && IS_OBJECT == Z_TYPE_P(php_sibling_iter)) {
        sibling_iter = (GtkTreeIter *) PHPG_GBOXED(php_sibling_iter);
    }

    gtk_tree_store_insert_before(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), &iter, parent_iter, sibling_iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items TSRMLS_CC) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}


%%
add-arginfo GtkTreeStore insert_after
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, parent, GtkTreeIter, 1)
    ZEND_ARG_OBJ_INFO(0, sibling, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_insert_after
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;
    zval *php_parent_iter = NULL, *php_sibling_iter = NULL;
    GtkTreeIter *parent_iter = NULL, *sibling_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|NNa", &php_sibling_iter, gtktreeiter_ce, &php_parent_iter, gtktreeiter_ce, &items))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }
    if (php_sibling_iter && IS_OBJECT == Z_TYPE_P(php_sibling_iter)) {
        sibling_iter = (GtkTreeIter *) PHPG_GBOXED(php_sibling_iter);
    }

    gtk_tree_store_insert_after(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), &iter, parent_iter, sibling_iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items TSRMLS_CC) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}


%%
add-arginfo GtkTreeStore set
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 3)
    ZEND_ARG_OBJ_INFO(0, iter, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, column)
    ZEND_ARG_INFO(0, value)
    ZEND_ARG_INFO(0, column)
    ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_set
PHP_METHOD
{
    phpg_store_set_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, TRUE);
}


%%
override-handler GtkTreeStore count_elements

static int phpg_gtktreemodel_count_elements_handler(zval *object, long *count TSRMLS_DC)
{
    *count = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(PHPG_GOBJECT(object)), NULL);
    return SUCCESS;
}

static int phpg_gtktreestore_count_elements_handler(zval *object, long *count TSRMLS_DC)
{
    return phpg_gtktreemodel_count_elements_handler(object, count TSRMLS_CC);
}


%%
override-handler GtkTreeStore has_dimension

static int phpg_gtktreemodel_has_dimension_handler(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
    GtkTreeModel *model;
    GtkTreeIter iter;
    zval tmp_offset;
    GtkTreePath *path = NULL;
    int result = 1;

    if (phpg_gboxed_check(offset, GTK_TYPE_TREE_ITER, TRUE TSRMLS_CC)) {
        return 1;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(object));

    if (Z_TYPE_P(offset) == IS_LONG && Z_LVAL_P(offset) < 0) {
        int n_columns = gtk_tree_model_get_n_columns(model);
        tmp_offset = *offset;
        ZVAL_LONG(&tmp_offset, Z_LVAL_P(offset) + n_columns);
        offset = &tmp_offset;
    }

    if (phpg_tree_path_from_zval(offset, &path TSRMLS_CC) == FAILURE) {
        return 0;
    }
    
    if (!gtk_tree_model_get_iter(model, &iter, path)) {
        result = 0;
    }

    gtk_tree_path_free(path);
    return result;
}

static int phpg_gtktreestore_has_dimension_handler(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
    return phpg_gtktreemodel_has_dimension_handler(object, offset, check_empty TSRMLS_CC);
}

%%
override-handler GtkTreeStore read_dimension

static zval* phpg_gtktreemodel_read_dimension_handler(zval *object, zval *offset, int type TSRMLS_DC)
{
    GtkTreeModel *model;
    GtkTreePath *path = NULL;
    GtkTreeIter iter;
    zval tmp_offset;
    zval *result = NULL;

    MAKE_STD_ZVAL(result);
    ZVAL_NULL(result);
    result->refcount = 0;
    result->is_ref = 0;

    if (phpg_gboxed_check(offset, GTK_TYPE_TREE_ITER, TRUE TSRMLS_CC)) {
        phpg_modelrow_new(&result, GTK_TREE_MODEL(PHPG_GOBJECT(object)), (GtkTreeIter *)
                          PHPG_GBOXED(offset) TSRMLS_CC);
        return result;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(object));

    if (Z_TYPE_P(offset) == IS_LONG && Z_LVAL_P(offset) < 0) {
        int n_columns = gtk_tree_model_get_n_columns(model);
        tmp_offset = *offset;
        ZVAL_LONG(&tmp_offset, Z_LVAL_P(offset) + n_columns);
        offset = &tmp_offset;
    }

    if (phpg_tree_path_from_zval(offset, &path TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "Could not parse index as a tree path");
        zval_dtor(result);
        FREE_ZVAL(result);
        return EG(uninitialized_zval_ptr);
    }

    if (gtk_tree_model_get_iter(model, &iter, path)) {
        phpg_modelrow_new(&result, model, &iter TSRMLS_CC);
    } else {
        php_error(E_WARNING, "Invalid tree path");
        zval_dtor(result);
        FREE_ZVAL(result);
        result = EG(uninitialized_zval_ptr);
    }
    gtk_tree_path_free(path);

    return result;
}

static zval* phpg_gtktreestore_read_dimension_handler(zval *object, zval *offset, int type TSRMLS_DC)
{
    return phpg_gtktreemodel_read_dimension_handler(object, offset, type TSRMLS_CC);
}

%%
override-handler GtkTreeStore write_dimension

static void phpg_gtktreemodel_write_dimension_handler(zval *object, zval *offset, zval *value TSRMLS_DC)
{
    GtkTreeIter *iter, tmp_iter;
    GtkTreeModel *model;

    model = GTK_TREE_MODEL(PHPG_GOBJECT(object));

    if (phpg_gboxed_check(offset, GTK_TYPE_TREE_ITER, TRUE TSRMLS_CC)) {
        iter = (GtkTreeIter *) PHPG_GBOXED(offset);
    } else {
        GtkTreePath *path;
        zval tmp_offset;

        if (Z_TYPE_P(offset) == IS_LONG && Z_LVAL_P(offset) < 0) {
            int n_columns = gtk_tree_model_get_n_columns(model);
            tmp_offset = *offset;
            ZVAL_LONG(&tmp_offset, Z_LVAL_P(offset) + n_columns);
            offset = &tmp_offset;
        }

        if (phpg_tree_path_from_zval(offset, &path TSRMLS_CC) == FAILURE) {
            php_error(E_WARNING, "Could not parse index as a tree path");
            return;
        }

        if (!gtk_tree_model_get_iter(model, &tmp_iter, path)) {
            php_error(E_WARNING, "Invalid tree path");
            gtk_tree_path_free(path);
            return;
        }

        iter = &tmp_iter;
        gtk_tree_path_free(path);
    }

    if (value == NULL) {
        phpg_model_remove_row(model, iter TSRMLS_CC);
    } else {
        phpg_model_set_row(model, iter, value TSRMLS_CC);
    }
}

static void phpg_gtktreestore_write_dimension_handler(zval *object, zval *offset, zval *value TSRMLS_DC)
{
    phpg_gtktreemodel_write_dimension_handler(object, offset, value TSRMLS_CC);
}

%%
override-handler GtkTreeStore unset_dimension

static void phpg_gtktreestore_unset_dimension_handler(zval *object, zval *offset TSRMLS_DC)
{
    phpg_gtktreemodel_write_dimension_handler(object, offset, NULL TSRMLS_CC);
}

%% }}}

%% {{{ GtkTreeModel

%%
add-arginfo GtkTreeModel get_iter
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, treepath)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_get_iter
PHP_METHOD
{
    zval *php_path = NULL;
    GtkTreeIter iter;
    GtkTreePath *path;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_path))
        return;

    if (phpg_tree_path_from_zval(php_path, &path TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects path argument to be a valid tree path specification", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, path)) {
        gtk_tree_path_free(path);
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        gtk_tree_path_free(path);
        php_error(E_WARNING, "%s::%s(): invalid tree path", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
    }
}

%%
override gtk_tree_model_get_iter_first
PHP_METHOD
{
    GtkTreeIter iter;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    }
}

%%
add-arginfo GtkTreeModel get_iter_from_string
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, path)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_get_iter_from_string
PHP_METHOD
{
    char *path_string = NULL;
    GtkTreeIter iter;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &path_string))
        return;

    if (!gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, path_string)) {
        return;
    }

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
add-arginfo GtkTreeModel get_value
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, iter, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, column)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_get_value
PHP_METHOD
{
    zval *php_iter;
    GtkTreeIter *iter;
    GtkTreeModel *model;
    gint column;
    GValue value = { 0 };

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Oi", &php_iter, gtktreeiter_ce, &column))
        return;

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
        php_error(E_WARNING, "%s::%s(): column  is out of range - model has %d column(s)",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                  gtk_tree_model_get_n_columns(model));
        return;
    }

    gtk_tree_model_get_value(model, iter, column, &value);
    phpg_gvalue_to_zval(&value, &return_value, TRUE, TRUE TSRMLS_CC);
    g_value_unset(&value);
}

%%
add-arginfo GtkTreeModel iter_children
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, parent_iter, GtkTreeIter, 1)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_iter_children
PHP_METHOD
{
    GtkTreeIter iter;
    zval *php_parent_iter = NULL;
    GtkTreeIter *parent_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|N", &php_parent_iter, gtktreeiter_ce))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }

    if (gtk_tree_model_iter_children(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, parent_iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_NULL();
    }
}

%%
add-arginfo GtkTreeModel iter_nth_child
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, parent_iter, GtkTreeIter, 1)
    ZEND_ARG_INFO(0, n)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_iter_nth_child
PHP_METHOD
{
    GtkTreeIter iter;
    zval *php_parent_iter = NULL;
    GtkTreeIter *parent_iter = NULL;
    int n;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Ni", &php_parent_iter, gtktreeiter_ce, &n))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }

    if (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, parent_iter, n)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_NULL();
    }
}

%%
add-arginfo GtkTreeModel iter_parent
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_OBJ_INFO(0, iter, GtkTreeIter, 1)
ZEND_END_ARG_INFO();


%%
override gtk_tree_model_iter_parent
PHP_METHOD
{
    GtkTreeIter iter;
    zval *php_child_iter = NULL;
    GtkTreeIter *child_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|N", &php_child_iter, gtktreeiter_ce))
        return;

    if (php_child_iter && IS_OBJECT == Z_TYPE_P(php_child_iter)) {
        child_iter = (GtkTreeIter *) PHPG_GBOXED(php_child_iter);
    }

    if (gtk_tree_model_iter_parent(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, child_iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_NULL();
    }
}

%%
add-arginfo GtkTreeModel iter_next
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, iter, GtkTreeIter, 1)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_iter_next
PHP_METHOD
{
    GtkTreeIter iter;
    zval *php_iter;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "O", &php_iter, gtktreeiter_ce))
        return;

    iter = *(GtkTreeIter *) PHPG_GBOXED(php_iter);

    if (gtk_tree_model_iter_next(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_NULL();
    }
}

%%
add-arginfo GtkTreeModel filter_new
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_OBJ_INFO(0, model, GtkTreeModel, 1)
    ZEND_ARG_INFO(0, root)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_filter_new
PHP_METHOD
{
    GObject *wrapped_obj;
    GtkTreePath *path = NULL;
    zval *php_model = NULL, *php_path = NULL;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V|s", &php_model, gtktreemodel_ce, &php_path))
        return;

    if (php_path && phpg_tree_path_from_zval(php_path, &path TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects path argument to be a valid tree path specification", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }


    wrapped_obj = g_object_new(phpg_gtype_from_zval(this_ptr),
                               "child-model", GTK_TREE_MODEL(PHPG_GOBJECT(php_model)),
                               "virtual-root", path,
                               NULL);

    if (path) {
        gtk_tree_path_free(path);
    }

    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeModelFilter);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
add-arginfo GtkTreeModel foreach
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_foreach

gboolean phpg_tree_model_foreach_marshal(GtkTreeModel *model,
                                         GtkTreePath  *path,
                                         GtkTreeIter  *iter,
                                         gpointer      data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_model = NULL, *php_path = NULL, *php_iter = NULL;
    gboolean ret;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return TRUE;
    }

    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_tree_path_to_zval(path, &php_path TSRMLS_CC);
    phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, iter, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 3, &n_args);
    args[0] = &php_model;
    args[1] = &php_path;
    args[2] = &php_iter;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_path);
    zval_ptr_dtor(&php_iter);

    if (retval) {
        ret = zend_is_true(retval);
        zval_ptr_dtor(&retval);
    } else {
        ret = TRUE;
    }

    efree(callback_name);
    efree(args);

    phpg_handle_marshaller_exception(TSRMLS_C);

    return ret;
}

PHP_METHOD
{
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 1, &extra, "V", &callback)) {
        return;
    }

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    gtk_tree_model_foreach(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)),
                           phpg_tree_model_foreach_marshal, cb_data);
    phpg_cb_data_destroy(cb_data);
}

%%
override gtk_tree_model_get
PHP_METHOD
{
    GtkTreeModel *model;
    GtkTreeIter *iter;
    zval *columns = NULL, *php_iter, **item;
    int n_columns;
    zend_bool varargs = FALSE;

    NOT_STATIC_METHOD();

    if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "Oa", &php_iter, gtktreeiter_ce, &columns)) {
        varargs = FALSE;
    } else if (php_gtk_parse_varargs(ZEND_NUM_ARGS(), 1, &columns, "O", &php_iter, gtktreeiter_ce)) {
        varargs = TRUE;
    }  else {
        return;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    array_init(return_value);
    n_columns = gtk_tree_model_get_n_columns(model);

    if (columns) {
        for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(columns));
             zend_hash_get_current_data(Z_ARRVAL_P(columns), (void**)&item) == SUCCESS;
             zend_hash_move_forward(Z_ARRVAL_P(columns))) {

            GValue value = { 0, };
            zval *zv = NULL;

            convert_to_long_ex(item);
            if (Z_LVAL_PP(item) < 0 || Z_LVAL_PP(item) >= n_columns) {
                php_error(E_WARNING, "%s::%s(): column number is out of range - model has %d columns", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), n_columns);
                if (varargs) zval_ptr_dtor(&columns);
                zval_dtor(return_value);
                RETURN_NULL();
            }

            gtk_tree_model_get_value(model, iter, Z_LVAL_PP(item), &value);
            if (phpg_gvalue_to_zval(&value, &zv, TRUE, TRUE TSRMLS_CC) == FAILURE) {
                g_value_unset(&value);
                if (varargs) zval_ptr_dtor(&columns);
                zval_dtor(return_value);
                RETURN_NULL();
            }
            add_next_index_zval(return_value, zv);
            g_value_unset(&value);
        }

        if (varargs) zval_ptr_dtor(&columns);
    }
}

%% }}}

%% {{{ GtkTreeModelFilter

%%
add-arginfo GtkTreeModelFilter set_visible_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_filter_set_visible_func
static gboolean phpg_tree_model_filter_visible_func_marshal(GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_model = NULL, *php_iter = NULL;
    gboolean show = TRUE;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return 0;
    }

    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, iter, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 2, &n_args);
    args[0] = &php_model;
    args[1] = &php_iter;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_iter);

    if (retval) {
        show = zend_is_true(retval);
        zval_ptr_dtor(&retval);
    } else {
        show = TRUE;
    }

    phpg_handle_marshaller_exception(TSRMLS_C);

    efree(callback_name);
    efree(args);

    return show;
}

PHP_METHOD
{
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 1, &extra, "V", &callback))
        return;

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(PHPG_GOBJECT(this_ptr)),
                                                           (GtkTreeModelFilterVisibleFunc)phpg_tree_model_filter_visible_func_marshal,
                                                           cb_data, phpg_cb_data_destroy);
}

%% }}}

%% {{{ GtkTreeSelection

%%
override gtk_tree_selection_get_selected
PHP_METHOD
{
    GtkTreeSelection *sel;
    GtkTreeIter iter;
    GtkTreeModel *model = NULL;
    zval *php_iter = NULL, *php_model = NULL;
    int result;

    NOT_STATIC_METHOD();

    sel = GTK_TREE_SELECTION(PHPG_GOBJECT(this_ptr));
    if (gtk_tree_selection_get_mode(sel) == GTK_SELECTION_MULTIPLE) {
        php_error(E_WARNING, "%s::%s() cannot be used because the selection mode is Gtk::SELECTION_MULTIPLE",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;
    
    result = gtk_tree_selection_get_selected(sel, &model, &iter);
    phpg_gobject_new(&php_model, (GObject *)model TSRMLS_CC);
    if (result) {
        phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
        php_gtk_build_value(&return_value, "(NN)", php_model, php_iter);
    } else {
        php_gtk_build_value(&return_value, "(Nn)", php_model);
    }
}

%%
override gtk_tree_selection_get_selected_rows
PHP_METHOD
{
    GtkTreeModel *model = NULL;
    GList *selected, *tmp;
    zval *php_selected = NULL, *php_model = NULL;

    NOT_STATIC_METHOD();
    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;
    
    selected = gtk_tree_selection_get_selected_rows(GTK_TREE_SELECTION(PHPG_GOBJECT(this_ptr)), &model);
    phpg_gobject_new(&php_model, (GObject *)model TSRMLS_CC);
    if (selected) {
        MAKE_STD_ZVAL(php_selected);
        array_init(php_selected);
        for (tmp = selected; tmp != NULL; tmp = tmp->next) {
            GtkTreePath *path = tmp->data;
            zval *item = NULL;
            
            phpg_tree_path_to_zval(path, &item TSRMLS_CC);
            add_next_index_zval(php_selected, item);
            gtk_tree_path_free(path);
        }
        php_gtk_build_value(&return_value, "(NN)", php_model, php_selected);
        g_list_free(selected);
    } else {
        php_gtk_build_value(&return_value, "(Nn)", php_model);
    }
}

%% }}}

%% {{{ GtkTreeSortable

%%
override gtk_tree_sortable_get_sort_column_id
PHP_METHOD
{
    gint sort_column_id;
    GtkSortType order;

    NOT_STATIC_METHOD();
    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_tree_sortable_get_sort_column_id(GTK_TREE_SORTABLE(PHPG_GOBJECT(this_ptr)), &sort_column_id, &order);

    php_gtk_build_value(&return_value, "(ii)", sort_column_id, (int)order);
}

%%
add-arginfo GtkTreeSortable set_default_sort_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_sortable_set_default_sort_func
PHP_METHOD
{
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 1, &extra, "V", &callback))
        return;

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(PHPG_GOBJECT(this_ptr)),
                                                           (GtkTreeIterCompareFunc)phpg_tree_iter_compare_func_marshal,
                                                           cb_data, phpg_cb_data_destroy);
}

%%
add-arginfo GtkTreeSortable set_sort_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, column)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_sortable_set_sort_func

static gint phpg_tree_iter_compare_func_marshal(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_model = NULL, *php_iter_a = NULL, *php_iter_b = NULL;
    gint compared = 0;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return 0;
    }

    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_gboxed_new(&php_iter_a, GTK_TYPE_TREE_ITER, a, TRUE, TRUE TSRMLS_CC);
    phpg_gboxed_new(&php_iter_b, GTK_TYPE_TREE_ITER, b, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 3, &n_args);
    args[0] = &php_model;
    args[1] = &php_iter_a;
    args[2] = &php_iter_b;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_iter_a);
    zval_ptr_dtor(&php_iter_b);

    if (retval) {
        convert_to_long(retval);
        compared = Z_LVAL_P(retval);
        zval_ptr_dtor(&retval);
    } else {
        compared = 0;
    }

    phpg_handle_marshaller_exception(TSRMLS_C);

    efree(callback_name);
    efree(args);

    return compared;
}

PHP_METHOD
{
    gint sort_column_id;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 2, &extra, "iV", &sort_column_id, &callback))
        return;

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(PHPG_GOBJECT(this_ptr)),
                                                           sort_column_id,
                                                           (GtkTreeIterCompareFunc)phpg_tree_iter_compare_func_marshal,
                                                           cb_data, phpg_cb_data_destroy);
}

%% }}}

%% {{{ GtkTreeView

%%
override gtk_tree_view_get_columns
PHP_METHOD
{
    GList *columns, *item;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    columns = gtk_tree_view_get_columns(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)));

    array_init(return_value);
    for (item = columns; item; item = item->next) {
        zval *php_column = NULL;
        phpg_gobject_new(&php_column, G_OBJECT(item->data) TSRMLS_CC);
        add_next_index_zval(return_value, php_column);
    }
    g_list_free(columns);
}

%%
add-arginfo GtkTreeView set_row_separator_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_set_row_separator_func

static gboolean phpg_tree_view_row_separator_func_marshal(GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_model = NULL, *php_iter = NULL;
    gboolean is_separator = FALSE;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return 0;
    }

    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, iter, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 2, &n_args);
    args[0] = &php_model;
    args[1] = &php_iter;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_iter);

    if (retval) {
        is_separator = zend_is_true(retval);
        zval_ptr_dtor(&retval);
    } else {
        is_separator = FALSE;
    }

    phpg_handle_marshaller_exception(TSRMLS_C);

    efree(callback_name);
    efree(args);

    return is_separator;
}

PHP_METHOD
{
    zval *php_callback, *extra;
    phpg_cb_data_t *cb_data;
    GtkTreeViewRowSeparatorFunc callback;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 1, &extra, "V", &php_callback))
        return;

    if (php_callback) {
        if (Z_TYPE_P(php_callback) == IS_NULL) {
            cb_data  = NULL;
            callback = NULL;
        } else {
            zval_add_ref(&php_callback);
            cb_data  = phpg_cb_data_new(php_callback, extra TSRMLS_CC);
            callback = (GtkTreeViewRowSeparatorFunc)phpg_tree_view_row_separator_func_marshal;
        }
    }

    gtk_tree_view_set_row_separator_func(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)),
                                                           callback,
                                                           cb_data, phpg_cb_data_destroy);
}

%% }}}

%%add-arginfo GtkTreeView insert_column_with_data_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, position)
    ZEND_ARG_INFO(0, title)
    ZEND_ARG_OBJ_INFO(0, cellrenderer, GtkCellRenderer, 1)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_insert_column_with_data_func

static void phpg_cell_data_func_marshal(GtkCellLayout *cell_layout, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_cell_layout = NULL, *php_renderer = NULL, *php_model = NULL, *php_iter = NULL;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return;
    }

    phpg_gobject_new(&php_cell_layout, (GObject*)cell_layout TSRMLS_CC);
    phpg_gobject_new(&php_renderer,    (GObject*)renderer    TSRMLS_CC);
    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, iter, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 4, &n_args);
    args[0] = &php_cell_layout;
    args[1] = &php_renderer;
    args[2] = &php_model;
    args[3] = &php_iter;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_cell_layout);
    zval_ptr_dtor(&php_renderer);
    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_iter);

    if (retval) {
        zval_ptr_dtor(&retval);
    }

    phpg_handle_marshaller_exception(TSRMLS_C);

    efree(callback_name);
    efree(args);
}

PHP_METHOD
{
    gint position;
    char *title;
    zval *php_cell;
    GtkCellRenderer *cell;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 4, &extra, "isOV", &position, &title, &php_cell, gtkcellrenderer_ce, &callback))
        return;

    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    RETURN_LONG(gtk_tree_view_insert_column_with_data_func(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)),
                                                           position, title, cell,
                                                           (GtkTreeCellDataFunc)phpg_cell_data_func_marshal,
                                                           cb_data, phpg_cb_data_destroy));
}

%%
override gtk_tree_view_get_cursor
PHP_METHOD
{
    GtkTreePath *path = NULL;
    GtkTreeViewColumn *column = NULL;
    zval *php_path = NULL, *php_column = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "")) {
        return;
    }

    gtk_tree_view_get_cursor(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)), &path, &column);

    array_init(return_value);

    if (path) {
        phpg_tree_path_to_zval(path, &php_path TSRMLS_CC);
    } else {
        ALLOC_INIT_ZVAL(php_path);
    }

    if (column) {
        phpg_gobject_new(&php_column, (GObject*)column TSRMLS_CC);
    } else {
        ALLOC_INIT_ZVAL(php_column);
    }

    php_gtk_build_value(&return_value, "(NN)", php_path, php_column);
}

%%
add-arginfo GtkTreeView get_path_at_pos
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, x)
    ZEND_ARG_INFO(0, y)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_get_path_at_pos

PHP_METHOD
{
    gint x, y;
    gint cell_x, cell_y;
    GtkTreePath *path;
    GtkTreeViewColumn *column;
    zval *php_path = NULL, *php_column = NULL;

    NOT_STATIC_METHOD();
    
    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ii", &x, &y)) {
        return;
    }

    if (!gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)), x, y, &path,
                                       &column, &cell_x, &cell_y)) {
        return;
    }

    array_init(return_value);

    if (path) {
        phpg_tree_path_to_zval(path, &php_path TSRMLS_CC);
    } else {
        MAKE_STD_ZVAL(php_path);
    }
    add_next_index_zval(return_value, php_path);

    phpg_gobject_new(&php_column, (GObject*)column TSRMLS_CC);
    add_next_index_zval(return_value, php_column);
    add_next_index_long(return_value, cell_x);
    add_next_index_long(return_value, cell_y);
}


%%
override gtk_tree_view_get_visible_rect
PHP_METHOD
{
    GdkRectangle rect;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)), &rect);
    phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE TSRMLS_CC);
}


%%
add-arginfo GtkTreeView tree_to_widget_coords
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, tx)
    ZEND_ARG_INFO(0, ty)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_tree_to_widget_coords
PHP_METHOD
{
    gint tx, ty, wx, wy;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ii", &tx, &ty))
        return;

    gtk_tree_view_tree_to_widget_coords(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)), tx, ty, &wx, &wy);
    php_gtk_build_value(&return_value, "(ii)", wx, wy);
}


%%
add-arginfo GtkTreeView widget_to_tree_coords
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, wx)
    ZEND_ARG_INFO(0, wy)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_widget_to_tree_coords
PHP_METHOD
{
    gint wx, wy, tx, ty;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "ii", &wx, &wy))
        return;

    gtk_tree_view_widget_to_tree_coords(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)), wx, wy, &tx, &ty);
    php_gtk_build_value(&return_value, "(ii)", tx, ty);
}

%% }}}

%% {{{ GtkTreeViewColumn

%%
add-arginfo GtkTreeViewColumn __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, title)
    ZEND_ARG_OBJ_INFO(0, cellrenderer, GtkCellRenderer, 1)
    ZEND_ARG_INFO(0, attribute)
    ZEND_ARG_INFO(0, column)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_column_new_with_attributes
PHP_METHOD
{
    char *title = NULL;
    zval *php_cell = NULL;
    GtkCellRenderer *cell = NULL;
    GtkTreeViewColumn *tvc = NULL;
    zval ***args = NULL;
    zend_bool free_title = FALSE;
    int i, argc = ZEND_NUM_ARGS();

    if (argc <= 2) {
        if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|uN", &title, &free_title, &php_cell, gtkcellrenderer_ce)) {
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
    } else {
        if (!php_gtk_parse_args(2, "|uN", &title, &free_title, &php_cell, gtkcellrenderer_ce)) {
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
    }

    tvc = GTK_TREE_VIEW_COLUMN(g_object_new(phpg_gtype_from_zval(this_ptr), NULL));
    if (php_cell && Z_TYPE_P(php_cell) != IS_NULL) {
        cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
    }

    if (title)
        gtk_tree_view_column_set_title(tvc, title);
    if (cell)
        gtk_tree_view_column_pack_start(tvc, cell, TRUE);

    if (argc > 2) {
        if (argc % 2) {
            php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }

        args = php_gtk_func_args(argc);
        for (i = 2; i < argc; i += 2) {
            zval *attr = *args[i];
            zval *column = *args[i+1];

            if (Z_TYPE_P(attr) != IS_STRING) {
                php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                          i, zend_zval_type_name(attr));
                efree(args);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
            }
            if (Z_TYPE_P(column) != IS_LONG) {
                php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                          i, zend_zval_type_name(column));
                efree(args);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
            }

            gtk_tree_view_column_add_attribute(tvc, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
        }
        efree(args);
    }

    phpg_gobject_set_wrapper(this_ptr, (GObject *)tvc TSRMLS_CC);
    if (free_title) g_free(title);
}



%%
add-arginfo GtkTreeViewColumn cell_get_position
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, cellrenderer, GtkCellRenderer, 1)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_column_cell_get_position
PHP_METHOD
{
    gint start_pos, width;
    zval *cellrenderer;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "O", &cellrenderer, gtkcellrenderer_ce))
        return;

    if (gtk_tree_view_column_cell_get_position(GTK_TREE_VIEW_COLUMN(PHPG_GOBJECT(this_ptr)), GTK_CELL_RENDERER(PHPG_GOBJECT(cellrenderer)), &start_pos, &width)) {
        php_gtk_build_value(&return_value, "(ii)", start_pos, width);
    } else {
        RETURN_FALSE;
    }
}


%%
override gtk_tree_view_column_cell_get_size
PHP_METHOD
{
    gint x_offset, y_offset, width, height;
    GdkRectangle cell_area;
    zval *php_cell_area = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "")) {
        return;
    }

    gtk_tree_view_column_cell_get_size(GTK_TREE_VIEW_COLUMN(PHPG_GOBJECT(this_ptr)), &cell_area, &x_offset, &y_offset, &width, &height);

    phpg_gboxed_new(&php_cell_area, GDK_TYPE_RECTANGLE, &cell_area, TRUE, TRUE TSRMLS_CC);

    php_gtk_build_value(&return_value, "(Niiii)", php_cell_area, x_offset, y_offset, width, height);
}


%%
override gtk_tree_view_column_get_cell_renderers
PHP_METHOD
{
    GList *list, *item;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    list = gtk_tree_view_column_get_cell_renderers(GTK_TREE_VIEW_COLUMN(PHPG_GOBJECT(this_ptr)));

    array_init(return_value);
    for (item = list; item; item = item->next) {
        zval *php_item = NULL;
        phpg_gobject_new(&php_item, G_OBJECT(item->data) TSRMLS_CC);
        add_next_index_zval(return_value, php_item);
    }

    g_list_free(list);
}


%% }}}
