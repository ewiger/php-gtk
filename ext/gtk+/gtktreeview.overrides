/* vim: set ft=cpp fdm=marker et: */

%%
headers

static void phpg_cell_data_func_marshal(GtkCellLayout *cell_layout, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data);
static void phpg_store_set_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool is_tree);


%% {{{ ignores
%%
ignore-glob
    gtk_tree_path_*
%%
ignore
    gtk_list_store_newv
    gtk_list_store_set_valist
    gtk_tree_row_reference_new_proxy
    gtk_tree_row_reference_inserted
    gtk_tree_row_reference_deleted
    gtk_tree_row_reference_reordered
    gtk_tree_store_newv
    gtk_tree_store_set_valist
    gtk_tree_view_new
    gtk_tree_view_column_new
    gtk_tree_view_column_set_attributes
%% }}}

%% {{{ GtkCellLayout
%%
add-arginfo GtkCellLayout set_attributes
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, cell)
    ZEND_ARG_INFO(0, attribute)
    ZEND_ARG_INFO(0, column)
ZEND_END_ARG_INFO();

%%
override gtk_cell_layout_set_attributes
PHP_METHOD
{
    zval *php_cell = NULL;
    GtkCellRenderer *cell = NULL;
    GtkCellLayout *layout = NULL;
    zval ***args = NULL;
    int i, argc = ZEND_NUM_ARGS();

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(1, "O", &php_cell, gtkcellrenderer_ce))
        return;

    if ((argc-1)% 2) {
        php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
    }

    layout = GTK_CELL_LAYOUT(PHPG_GOBJECT(this_ptr));
    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
    gtk_cell_layout_clear_attributes(layout, cell);
    args = php_gtk_func_args(argc);
    for (i = 1; i < argc; i += 2) {
        zval *attr = *args[i];
        zval *column = *args[i+1];

        if (Z_TYPE_P(attr) != IS_STRING) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(attr));
            efree(args);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
        if (Z_TYPE_P(column) != IS_LONG) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(column));
            efree(args);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }

        gtk_cell_layout_add_attribute(layout, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
    }
    efree(args);
}
%% }}}

%% {{{ GtkListStore
%%
add-arginfo GtkListStore __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, type_col_0)
    ZEND_ARG_INFO(0, type_col_1)
    ZEND_ARG_INFO(0, ...)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_new
PHP_METHOD
{
    zval ***args;
    GType *column_types;
    GObject *wrapped_obj;
    int i, argc = ZEND_NUM_ARGS();

    if (argc == 0) {
        php_error(E_WARNING, "%s::%s() requires at least 1 argument",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
    }

    args = php_gtk_func_args(argc);

    column_types = emalloc(argc * sizeof(GType));
    for (i = 0; i < argc; i++) {
        column_types[i] = phpg_gtype_from_zval(*args[i]);
        if (column_types[i] == 0) {
            efree(column_types);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
        }
    }
    
    wrapped_obj = g_object_newv(phpg_gtype_from_zval(this_ptr), 0, NULL);
    gtk_list_store_set_column_types(GTK_LIST_STORE(wrapped_obj), argc, column_types);
    efree(column_types);
    efree(args);
    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkListStore);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
add-arginfo GtkListStore append
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_append
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|a", &items))
        return;

    gtk_list_store_append(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), &iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
add-arginfo GtkListStore set
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, iter)
    ZEND_ARG_INFO(0, column)
    ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO();

%%
override gtk_list_store_set
static void phpg_store_set_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool is_tree)
{
    zval ***items;
    zval *php_iter;
    GtkTreeIter *iter = NULL;
    GtkTreeModel *model;
    int i, argc = ZEND_NUM_ARGS();

    NOT_STATIC_METHOD();

    if (argc < 3) {
        php_error(E_WARNING, "%s::%s() requires at least 3 arguments, %d given",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), argc);
        return;
    }

    if (!php_gtk_parse_args(1, "O", &php_iter, gtktreeiter_ce))
        return;

    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    if ((argc-1) % 2) {
        php_error(E_WARNING, "%s::%s() requires arguments 2-n to be column/value pairs",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    items = php_gtk_func_args(argc);
    for (i = 1; i < argc; i += 2) {
        zval *zcolumn = *items[i];
        zval *zvalue = *items[i+1];
        gint column;
        GValue value = { 0 };
        
        if (Z_TYPE_P(zcolumn) != IS_LONG) {
            php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, zend_zval_type_name(zcolumn));
            efree(items);
            return;
        }

        column = Z_LVAL_P(zcolumn);
        if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
            php_error(E_WARNING, "%s::%s(): argument %d is out of range - model has %d column(s)",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i, gtk_tree_model_get_n_columns(model));
            efree(items);
            return;
        }

        g_value_init(&value, gtk_tree_model_get_column_type(model, column));

        if (phpg_gvalue_from_zval(&value, zvalue TSRMLS_CC) == FAILURE) {
            php_error(E_WARNING, "%s::%s(): argument %d is of the wrong type for column %d",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                      i+1, column);
            efree(items);
            return;
        }

        if (is_tree) {
            gtk_tree_store_set_value(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), iter, column, &value);
        } else {
            gtk_list_store_set_value(GTK_LIST_STORE(PHPG_GOBJECT(this_ptr)), iter, column, &value);
        }

        g_value_unset(&value);
    }

    efree(items);
}

PHP_METHOD
{
    phpg_store_set_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, FALSE);
}
%% }}}

%% {{{ GtkTreeStore
%%
add-arginfo GtkTreeStore __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 1)
    ZEND_ARG_INFO(0, type_col_0)
    ZEND_ARG_INFO(0, type_col_1)
    ZEND_ARG_INFO(0, ...)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_new
PHP_METHOD
{
    zval ***args;
    GType *column_types;
    GObject *wrapped_obj;
    int i, argc = ZEND_NUM_ARGS();

    if (argc == 0) {
        php_error(E_WARNING, "%s::%s() requires at least 1 argument",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeStore);
    }

    args = php_gtk_func_args(argc);

    column_types = emalloc(argc * sizeof(GType));
    for (i = 0; i < argc; i++) {
        column_types[i] = phpg_gtype_from_zval(*args[i]);
        if (column_types[i] == 0) {
            efree(column_types);
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeStore);
        }
    }
    
    wrapped_obj = g_object_newv(phpg_gtype_from_zval(this_ptr), 0, NULL);
    gtk_tree_store_set_column_types(GTK_TREE_STORE(wrapped_obj), argc, column_types);
    efree(column_types);
    efree(args);
    if (!wrapped_obj) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeStore);
    }

    phpg_gobject_set_wrapper(this_ptr, wrapped_obj TSRMLS_CC);
}

%%
add-arginfo GtkTreeStore apend
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, iter)
    ZEND_ARG_INFO(0, items)
ZEND_END_ARG_INFO();

%%
override gtk_tree_store_append
PHP_METHOD
{
    GtkTreeIter iter;
    zval *items = NULL;
    zval *php_parent_iter = NULL;
    GtkTreeIter *parent_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|Na", &php_parent_iter, gtktreeiter_ce, &items))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }

    gtk_tree_store_append(GTK_TREE_STORE(PHPG_GOBJECT(this_ptr)), &iter, parent_iter);

    if (items && phpg_model_set_row(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, items) == FAILURE)
        return;

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}

%%
override gtk_tree_store_set
PHP_METHOD
{
    phpg_store_set_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, TRUE);
}
%% }}}

%% {{{ GtkTreeModel

%%
override gtk_tree_model_get_iter
PHP_METHOD
{
    zval *php_path = NULL;
    GtkTreeIter iter;
    GtkTreePath *path;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &path))
        return;

    if (phpg_tree_path_from_zval(php_path, &path TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects path argument to be a valid tree path specification", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, path)) {
        gtk_tree_path_free(path);
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        gtk_tree_path_free(path);
        php_error(E_WARNING, "%s::%s(): invalid tree path", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
    }
}

%%
override gtk_tree_model_get_iter_first
PHP_METHOD
{
    GtkTreeIter iter;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    }
}

%%
override gtk_tree_model_get_iter_from_string
PHP_METHOD
{
    char *path_string = NULL;
    GtkTreeIter iter;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &path_string))
        return;

    if (!gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, path_string)) {
        return;
    }

    phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
}
%%
override gtk_tree_model_get_value
PHP_METHOD
{
    zval *php_iter;
    GtkTreeIter *iter;
    GtkTreeModel *model;
    gint column;
    GValue value = { 0 };

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "Oi", &php_iter, gtktreeiter_ce, &column))
        return;

    model = GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr));
    iter = (GtkTreeIter *) PHPG_GBOXED(php_iter);

    if (column < 0 || column >= gtk_tree_model_get_n_columns(model)) {
        php_error(E_WARNING, "%s::%s(): column  is out of range - model has %d column(s)",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                  gtk_tree_model_get_n_columns(model));
        return;
    }

    gtk_tree_model_get_value(model, iter, column, &value);
    phpg_gvalue_to_zval(&value, &return_value, TRUE TSRMLS_CC);
    g_value_unset(&value);
}

%%
add-arginfo GtkTreeModel iter_children
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, parent_iter)
ZEND_END_ARG_INFO();

%%
override gtk_tree_model_iter_children
PHP_METHOD
{
    GtkTreeIter iter;
    zval *php_parent_iter = NULL;
    GtkTreeIter *parent_iter = NULL;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|N", &php_parent_iter, gtktreeiter_ce))
        return;

    if (php_parent_iter && IS_OBJECT == Z_TYPE_P(php_parent_iter)) {
        parent_iter = (GtkTreeIter *) PHPG_GBOXED(php_parent_iter);
    }

    if (gtk_tree_model_iter_children(GTK_TREE_MODEL(PHPG_GOBJECT(this_ptr)), &iter, parent_iter)) {
        phpg_gboxed_new(&return_value, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_NULL();
    }
}

%% }}}

%% {{{ GtkTreeSelection

%%
override gtk_tree_selection_get_selected
PHP_METHOD
{
    GtkTreeSelection *sel;
    GtkTreeIter iter;
    GtkTreeModel *model = NULL;
    zval *php_iter = NULL, *php_model = NULL;
    int result;

    NOT_STATIC_METHOD();

    sel = GTK_TREE_SELECTION(PHPG_GOBJECT(this_ptr));
    if (gtk_tree_selection_get_mode(sel) == GTK_SELECTION_MULTIPLE) {
        php_error(E_WARNING, "%s::%s() cannot be used because the selection mode is Gtk::SELECTION_MULTIPLE",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;
    
    result = gtk_tree_selection_get_selected(sel, &model, &iter);
    phpg_gobject_new(&php_model, (GObject *)model TSRMLS_CC);
    if (result) {
        phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE TSRMLS_CC);
        php_gtk_build_value(&return_value, "(NN)", php_model, php_iter);
    } else {
        php_gtk_build_value(&return_value, "(Nn)", php_model);
    }
}

%%
override gtk_tree_selection_get_selected_rows
PHP_METHOD
{
    GtkTreeModel *model = NULL;
    GList *selected, *tmp;
    zval *php_selected = NULL, *php_model = NULL;

    NOT_STATIC_METHOD();
    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;
    
    selected = gtk_tree_selection_get_selected_rows(GTK_TREE_SELECTION(PHPG_GOBJECT(this_ptr)), &model);
    phpg_gobject_new(&php_model, (GObject *)model TSRMLS_CC);
    if (selected) {
        MAKE_STD_ZVAL(php_selected);
        array_init(php_selected);
        for (tmp = selected; tmp != NULL; tmp = tmp->next) {
            GtkTreePath *path = tmp->data;
            zval *item = NULL;
            
            phpg_tree_path_to_zval(path, &item TSRMLS_CC);
            add_next_index_zval(php_selected, item);
            gtk_tree_path_free(path);
        }
        php_gtk_build_value(&return_value, "(NN)", php_model, php_selected);
        g_list_free(selected);
    } else {
        php_gtk_build_value(&return_value, "(Nn)", php_model);
    }
}

%% }}}

%% {{{ GtkTreeView

%%
add-arginfo GtkTreeView insert_column_with_data_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, position)
    ZEND_ARG_INFO(0, title)
    ZEND_ARG_INFO(0, cellrenderer)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_insert_column_with_data_func

static void phpg_cell_data_func_marshal(GtkCellLayout *cell_layout, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
{
    phpg_cb_data_t *cbd = (phpg_cb_data_t *) data;
    zval *retval = NULL;
    zval ***args = NULL;
    int n_args = 0;
    char *callback_name;
    zval *php_cell_layout = NULL, *php_renderer = NULL, *php_model = NULL, *php_iter = NULL;
    TSRMLS_FETCH();

    if (!zend_is_callable(cbd->callback, 0, &callback_name)) {
        php_error(E_WARNING, "Unable to invoke callback '%s' specified in %s on line %ld", callback_name, cbd->src_filename, cbd->src_lineno);
        efree(callback_name);
        return;
    }

    phpg_gobject_new(&php_cell_layout, (GObject*)cell_layout TSRMLS_CC);
    phpg_gobject_new(&php_renderer,    (GObject*)renderer    TSRMLS_CC);
    phpg_gobject_new(&php_model,       (GObject*)model       TSRMLS_CC);
    phpg_gboxed_new(&php_iter, GTK_TYPE_TREE_ITER, iter, TRUE, TRUE TSRMLS_CC);

    args = php_gtk_hash_as_array_offset(cbd->user_args, 4, &n_args);
    args[0] = &php_cell_layout;
    args[1] = &php_renderer;
    args[2] = &php_model;
    args[3] = &php_iter;

    call_user_function_ex(EG(function_table), NULL, cbd->callback, &retval, n_args, args, 0, NULL TSRMLS_CC);

    zval_ptr_dtor(&php_cell_layout);
    zval_ptr_dtor(&php_renderer);
    zval_ptr_dtor(&php_model);
    zval_ptr_dtor(&php_iter);

    if (retval) {
        zval_ptr_dtor(&retval);
    }

    efree(callback_name);
    efree(args);
}

PHP_METHOD
{
    gint position;
    char *title;
    zval *php_cell;
    GtkCellRenderer *cell;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 4, &extra, "isOV", &position, &title, &php_cell, gtkcellrenderer_ce, &callback))
        return;

    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    RETURN_LONG(gtk_tree_view_insert_column_with_data_func(GTK_TREE_VIEW(PHPG_GOBJECT(this_ptr)),
                                                           position, title, cell,
                                                           (GtkTreeCellDataFunc)phpg_cell_data_func_marshal,
                                                           cb_data, phpg_cb_data_destroy));
}

%% }}}

%% {{{ GtkTreeViewColumn
%%
add-arginfo GtkTreeViewColumn new_with_attributes
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, title)
    ZEND_ARG_INFO(0, cellrenderer)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_column_new_with_attributes
PHP_METHOD
{
    char *title = NULL;
    zval *php_cell = NULL;
    GtkCellRenderer *cell = NULL;
    GtkTreeViewColumn *tvc = NULL;
    zval ***args = NULL;
    int i, argc = ZEND_NUM_ARGS();

    if (argc <= 2) {
        if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|sN", &title, &php_cell, gtkcellrenderer_ce)) {
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
    } else {
        if (!php_gtk_parse_args(2, "|sN", &title, &php_cell, gtkcellrenderer_ce)) {
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }
    }

    tvc = GTK_TREE_VIEW_COLUMN(g_object_new(phpg_gtype_from_zval(this_ptr), NULL));
    if (php_cell && Z_TYPE_P(php_cell) != IS_NULL) {
        cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));
    }

    if (title)
        gtk_tree_view_column_set_title(tvc, title);
    if (cell)
        gtk_tree_view_column_pack_start(tvc, cell, TRUE);

    if (argc > 2) {
        if (argc % 2) {
            php_error(E_WARNING, "%s::%s() requires arguments 3-n to be attribute/column pairs",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
            PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
        }

        args = php_gtk_func_args(argc);
        for (i = 2; i < argc; i += 2) {
            zval *attr = *args[i];
            zval *column = *args[i+1];

            if (Z_TYPE_P(attr) != IS_STRING) {
                php_error(E_WARNING, "%s::%s() requires argument %d to be a string, %s given",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                          i, zend_zval_type_name(attr));
                efree(args);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
            }
            if (Z_TYPE_P(column) != IS_LONG) {
                php_error(E_WARNING, "%s::%s() requires argument %d to be an integer, %s given",
                          get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C),
                          i, zend_zval_type_name(column));
                efree(args);
                PHPG_THROW_CONSTRUCT_EXCEPTION(GtkTreeViewColumn);
            }

            gtk_tree_view_column_add_attribute(tvc, cell, Z_STRVAL_P(attr), Z_LVAL_P(column));
        }
        efree(args);
    }

    phpg_gobject_set_wrapper(this_ptr, (GObject *)tvc TSRMLS_CC);
}

%%
add-arginfo GtkTreeViewColumn set_cell_data_func
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, cellrenderer)
    ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO();

%%
override gtk_tree_view_column_set_cell_data_func
PHP_METHOD
{
    zval *php_cell;
    GtkCellRenderer *cell;
    zval *callback, *extra;
    phpg_cb_data_t *cb_data;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_varargs(ZEND_NUM_ARGS(), 2, &extra, "OV", &php_cell, gtkcellrenderer_ce, &callback))
        return;

    cell = GTK_CELL_RENDERER(PHPG_GOBJECT(php_cell));

    zval_add_ref(&callback);
    cb_data = phpg_cb_data_new(callback, extra TSRMLS_CC);

    gtk_tree_view_column_set_cell_data_func(GTK_TREE_VIEW_COLUMN(PHPG_GOBJECT(this_ptr)), cell,
                                            (GtkTreeCellDataFunc)phpg_cell_data_func_marshal,
                                            cb_data, phpg_cb_data_destroy);
}
%% }}}
