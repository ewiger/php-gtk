/* vim: set ft=cpp fdm=marker et: */
/* TODO
 * fix gdk_gc_new2
 */
%%
headers
#include <gdk-pixbuf/gdk-pixbuf.h>

#if defined(GDK_WINDOWING_X11)
#include <gdk/gdkx.h>
#elif defined(GDK_WINDOWING_WIN32)
#include <gdk/gdkwin32.h>
#endif

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

#define MAX_INTENSITY 65535

/* Forward declaration, since gen_gtk.h is generated later. */
extern PHP_GTK_EXPORT_CE(gtkwidget_ce);

#include "gen_pango.h"

static inline int clamp_int(int value, int low, int high)
{
    return (value < low ? low : (value > high ? high : value));
}

static ZEND_METHOD(GdkColormap, alloc_color);

/* {{{ ignores */
%%
ignore-glob
    *_get_type

%%
ignore
    GdkDebugFlag
    GdkColorInfoFlags
%%
ignore
    gdk_gc_new2
    gdk_string_extents

/* }}} */


%% {{{ GdkColor

%%
add-arginfo GdkColor __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, red)
    ZEND_ARG_INFO(0, blue)
    ZEND_ARG_INFO(0, green)
    ZEND_ARG_INFO(0, allocated)
ZEND_END_ARG_INFO();

%%
override gdk_color_new
PHP_METHOD
{
    guint red = 0;
    guint green = 0;
    guint blue = 0;
    guint pixel = 0;
    GdkColor color;
    phpg_gboxed_t *pobj = NULL;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|iiii", &red, &green, &blue, &pixel))
        return;

    color.red = clamp_int(red, 0, MAX_INTENSITY);
    color.green = clamp_int(green, 0, MAX_INTENSITY);
    color.blue = clamp_int(blue, 0, MAX_INTENSITY);
    color.pixel = pixel;

    pobj = zend_object_store_get_object(this_ptr TSRMLS_CC);
    pobj->gtype = GDK_TYPE_COLOR;
    pobj->boxed = g_boxed_copy(GDK_TYPE_COLOR, &color);
    pobj->free_on_destroy = TRUE;
}

%%
add-arginfo GdkColor parse
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, color)
ZEND_END_ARG_INFO();


%%
override gdk_color_parse parse ZEND_ACC_PUBLIC|ZEND_ACC_STATIC
PHP_METHOD
{
	gchar *color_spec;
	GdkColor color;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &color_spec)) {
		return;
	}

	if (gdk_color_parse(color_spec, &color)) {
        phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);
    } else {
        php_error(E_WARNING, "%s::%s() could not parse color spec '%s'",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), color_spec);
        RETURN_FALSE;
    }
}

%%
override-prop GdkColor red
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->red);
    return SUCCESS;
}
%%
override-prop GdkColor green
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->green);
    return SUCCESS;
}
%%
override-prop GdkColor blue
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->blue);
    return SUCCESS;
}
%%
override-prop GdkColor pixel
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->pixel);
    return SUCCESS;
}

%%
override-handler GdkColor write_property
void phpg_gdkcolor_write_property_handler(zval *object, zval *member, zval *value TSRMLS_DC)
{
    zval tmp_value;
	zval tmp_member;
    GdkColor *color;

 	if (member->type != IS_STRING) {
		tmp_member = *member;
		zval_copy_ctor(&tmp_member);
		convert_to_string(&tmp_member);
		member = &tmp_member;
	}

    if (value->type != IS_LONG) {
        tmp_value = *value;
        zval_copy_ctor(&tmp_value);
        convert_to_long(&tmp_value);
        value = &tmp_value;
    }

    color = (GdkColor *)PHPG_GBOXED(object);
    if (!strcmp(Z_STRVAL_P(member), "pixel")) {
        color->pixel = Z_LVAL_P(value);
    } else {
        if (!strcmp(Z_STRVAL_P(member), "red")) {
            color->red = clamp_int(Z_LVAL_P(value), 0, MAX_INTENSITY);
        } else if (!strcmp(Z_STRVAL_P(member), "green")) {
            color->green = clamp_int(Z_LVAL_P(value), 0, MAX_INTENSITY);
        } else if (!strcmp(Z_STRVAL_P(member), "blue")) {
            color->blue = clamp_int(Z_LVAL_P(value), 0, MAX_INTENSITY);
        }
    }

	if (member == &tmp_member) {
		zval_dtor(member);
	}
	if (value == &tmp_value) {
		zval_dtor(value);
	}
}

%%
override-handler GdkColor get_properties
HashTable* phpg_gdkcolor_get_properties_handler(zval *object TSRMLS_DC)
{
    phpg_head_t *poh = NULL;
    poh = (phpg_head_t *) zend_object_store_get_object(object TSRMLS_CC);
    phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                               STRS(red), STRS(green), STRS(blue), STRS(pixel), NULL);

	return poh->zobj.properties;
}

%%
override gdk_color_alloc
PHP_METHOD
{
	phpg_warn_deprecated("use GdkColormap::alloc_color()" TSRMLS_CC);
    PHP_FN(GdkColormap_alloc_color)(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}
%% }}}

%% {{{ GdkColormap

%%
add-arginfo GdkColormap alloc_color
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, color OR red)
    ZEND_ARG_INFO(0, blue)
    ZEND_ARG_INFO(0, green)
ZEND_END_ARG_INFO();

%%
override gdk_colormap_alloc_color
PHP_METHOD
{
    GdkColor color = { 0, 0, 0, 0 };
    guint red = 0, green = 0, blue = 0;
    zend_bool writeable = FALSE;
    zend_bool best_match = TRUE;
    zval *php_color;
	gchar *color_spec;

    NOT_STATIC_METHOD();

    if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "iii|bb", &red, &green, &blue, &writeable, &best_match)) {
        color.red = clamp_int(red, 0, MAX_INTENSITY);
        color.green = clamp_int(green, 0, MAX_INTENSITY);
        color.blue = clamp_int(blue, 0, MAX_INTENSITY);
    } else if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "O|bb",
                                        &php_color, gdkcolor_ce, &writeable, &best_match)) {
        color = *(GdkColor*)PHPG_GBOXED(php_color);
    } else if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "s|bb", &color_spec, &writeable, &best_match)) {
        if (!gdk_color_parse(color_spec, &color)) {
            php_error(E_WARNING, "%s::%s() could not parse color spec '%s'",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), color_spec);
            RETURN_FALSE;
        }
    } else {
            php_error(E_WARNING, "%s::%s() requires color to be specified as an RGB triplet, GdkColor, or a string", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
    }

	if (!gdk_colormap_alloc_color(GDK_COLORMAP(PHPG_GOBJECT(this_ptr)), &color, writeable, best_match)) {
        php_error(E_WARNING, "%s::%s() could not allocate color", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        RETURN_FALSE;
	}

    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);
}

%%
add-arginfo GdkColormap query_color
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, allocated)
ZEND_END_ARG_INFO();

%%
override gdk_colormap_query_color
PHP_METHOD
{
    GdkColor color = { 0 , 0 , 0 , 0 };
    guint pixel;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i", &pixel))
        return;
    gdk_colormap_query_color(GDK_COLORMAP(PHPG_GOBJECT(this_ptr)), pixel, &color);
    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);
}

%% }}}


%% {{{ GdkDisplay

%%
override gdk_display_get_window_at_pointer
PHP_METHOD
{
    gint x, y;
    GdkWindow *window;
    zval *php_window = NULL;

    NO_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    window = gdk_display_get_window_at_pointer(GDK_DISPLAY(PHPG_GOBJECT(this_ptr)), &x, &y);

    if (window != NULL) {
        phpg_gboxed_new(&php_window, GDK_TYPE_WINDOW, &window, TRUE, TRUE TSRMLS_CC);
        php_gtk_build_value(&return_value, "(Nii)", php_window, x, y);
    } else {
        RETURN_FALSE;
    }
}

%% }}}


%% {{{ GdkDrawable

%%
override gdk_drawable_get_size
PHP_METHOD
{
    gint width, height;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_drawable_get_size(GDK_DRAWABLE(PHPG_GOBJECT(this_ptr)), &width, &height);
    php_gtk_build_value(&return_value, "(ii)", width, height);
}

%% }}}


%% {{{ GdkEvent

%% {{{ read_property handler

%%
override-handler GdkEvent read_property
static zval* phpg_gdkevent_read_property_handler(zval *object, zval *member, int type TSRMLS_DC)
{
    zval tmp_member;
    zval *result = NULL;
    GdkEvent *event = (GdkEvent *) PHPG_GBOXED(object);
    char *name;

	if (member->type != IS_STRING) {
		tmp_member = *member;
		zval_copy_ctor(&tmp_member);
		convert_to_string(&tmp_member);
		member = &tmp_member;
	}

    name = Z_STRVAL_P(member);

    switch (event->type) {

        case GDK_NOTHING:
        case GDK_DELETE:
        case GDK_DESTROY:
            break;

        case GDK_EXPOSE:
            if (!strcmp(name, "area")) {
                phpg_gboxed_new(&result, GDK_TYPE_RECTANGLE, &event->expose.area, TRUE, TRUE TSRMLS_CC);
            } else if (!strcmp(name, "count")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->expose.count);
            }
            break;

        case GDK_MOTION_NOTIFY:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->motion.time);
            } else if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->motion.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->motion.y);
            } else if (!strcmp(name, "axes")) {
                ALLOC_ZVAL(result);
                if (event->motion.axes) {
                    gint i = 0;
                    array_init(result);
                    for (i = 0; i < event->motion.device->num_axes; i++) {
                        add_next_index_double(result, event->motion.axes[i]);
                    }
                } else {
                    ZVAL_NULL(result);
                }
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->motion.state);
            } else if (!strcmp(name, "is_hint")) {
                ALLOC_ZVAL(result);
                ZVAL_BOOL(result, event->motion.is_hint);
            } else if (!strcmp(name, "device")) {
                ALLOC_ZVAL(result);
                phpg_gobject_new(&result, (GObject *)event->motion.device TSRMLS_CC);
            } else if (!strcmp(name, "x_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->motion.x_root);
            } else if (!strcmp(name, "y_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->motion.y_root);
            }
            break;

        case GDK_BUTTON_PRESS:
        case GDK_2BUTTON_PRESS:
        case GDK_3BUTTON_PRESS:
        case GDK_BUTTON_RELEASE:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->button.time);
            } else if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.y);
            } else if (!strcmp(name, "axes")) {
                ALLOC_ZVAL(result);
                if (event->button.axes) {
                    gint i = 0;
                    array_init(result);
                    for (i = 0; i < event->button.device->num_axes; i++) {
                        add_next_index_double(result, event->button.axes[i]);
                    }
                } else {
                    ZVAL_NULL(result);
                }
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->button.state);
            } else if (!strcmp(name, "button")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->button.button);
            } else if (!strcmp(name, "device")) {
                ALLOC_ZVAL(result);
                phpg_gobject_new(&result, (GObject *)event->button.device TSRMLS_CC);
            } else if (!strcmp(name, "x_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.x_root);
            } else if (!strcmp(name, "y_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.y_root);
            }
            break;

        case GDK_KEY_PRESS:
        case GDK_KEY_RELEASE:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.time);
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.state);
            } else if (!strcmp(name, "keyval")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.keyval);
            } else if (!strcmp(name, "string")) {
                ALLOC_ZVAL(result);
                ZVAL_STRINGL(result, event->key.string, event->key.length, 1);
            } else if (!strcmp(name, "hardware_keycode")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.hardware_keycode);
            } else if (!strcmp(name, "group")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.group);
            }
            break;

        case GDK_ENTER_NOTIFY:
        case GDK_LEAVE_NOTIFY:
            if (!strcmp(name, "subwindow")) {
                ALLOC_ZVAL(result);
                phpg_gobject_new(&result, (GObject *)event->crossing.subwindow TSRMLS_CC);
            } else if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->crossing.time);
            } else if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->crossing.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->crossing.y);
            } else if (!strcmp(name, "x_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->crossing.x_root);
            } else if (!strcmp(name, "y_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->crossing.y_root);
            } else if (!strcmp(name, "mode")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->crossing.mode);
            } else if (!strcmp(name, "detail")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->crossing.detail);
            } else if (!strcmp(name, "focus")) {
                ALLOC_ZVAL(result);
                ZVAL_BOOL(result, event->crossing.focus);
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->crossing.state);
            }
            break;

        case GDK_FOCUS_CHANGE:
            if (!strcmp(name, "in")) {
                ALLOC_ZVAL(result);
                ZVAL_BOOL(result, event->focus_change.in);
            }
            break;

        case GDK_CONFIGURE:
            if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.y);
            } else if (!strcmp(name, "width")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.width);
            } else if (!strcmp(name, "height")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.height);
            }
            break;

        case GDK_MAP:
        case GDK_UNMAP:
            break;

        case GDK_PROPERTY_NOTIFY:
            if (!strcmp(name, "atom")) { /* TODO GdkAtom is a struct */
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->property.time);
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->property.state);
            }
            break;

        case GDK_SELECTION_CLEAR:
        case GDK_SELECTION_REQUEST:
        case GDK_SELECTION_NOTIFY:
            if (!strcmp(name, "selection")) { /* TODO GdkAtom is a struct */
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "target")) { /* TODO GdkAtom */
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "property")) { /* TODO GdkAtom */
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->selection.time);
            } else if (!strcmp(name, "requestor")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->selection.requestor);
            }
            break;

        case GDK_PROXIMITY_IN:
        case GDK_PROXIMITY_OUT:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->proximity.time);
            } else if (!strcmp(name, "device")) {
                ALLOC_ZVAL(result);
                phpg_gobject_new(&result, (GObject *)event->proximity.device TSRMLS_CC);
            }
            break;

        case GDK_DRAG_ENTER:
        case GDK_DRAG_LEAVE:
        case GDK_DRAG_MOTION:
        case GDK_DRAG_STATUS:
        case GDK_DROP_START:
        case GDK_DROP_FINISHED:
            if (!strcmp(name, "context")) { /* GdkDragContext is a struct */
                ALLOC_ZVAL(result);
                phpg_gobject_new(&result, (GObject *)event->dnd.context TSRMLS_CC);
            } else if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->dnd.time);
            } else if (!strcmp(name, "x_root")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->dnd.x_root);
            } else if (!strcmp(name, "y_root")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->dnd.y_root);
            }
            break;

        case GDK_CLIENT_EVENT:
            if (!strcmp(name, "message_type")) { /* TODO GdkAtom is a struct */
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "data_format")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->client.data_format);
            } else if (!strcmp(name, "data.b")) {
                ALLOC_ZVAL(result);
                ZVAL_STRINGL(result, event->client.data.b, 20, 1); /* Why 20? */
            }
            break;

        case GDK_VISIBILITY_NOTIFY:
            if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->visibility.state);
            }
            break;

        case GDK_NO_EXPOSE:
            break;

        case GDK_SCROLL:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->scroll.time);
            } else if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->scroll.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->scroll.y);
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->scroll.state);
            } else if (!strcmp(name, "direction")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->scroll.direction);
            } else if (!strcmp(name, "device")) {
                ALLOC_ZVAL(result);
                phpg_gobject_new(&result, (GObject *)event->scroll.device TSRMLS_CC);
            } else if (!strcmp(name, "x_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->scroll.x_root);
            } else if (!strcmp(name, "y_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->scroll.y_root);
            }
            break;

        case GDK_WINDOW_STATE:
            if (!strcmp(name, "changed_mask")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->window_state.changed_mask);
            } else if (!strcmp(name, "new_window_state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->window_state.new_window_state);
            }
            break;

        case GDK_SETTING:
            if (!strcmp(name, "action")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->setting.action);
            } else if (!strcmp(name, "name")) {
                ALLOC_ZVAL(result);
                ZVAL_STRINGL(result, event->setting.name, strlen(event->setting.name), 1);
            }
            break;

        case GDK_OWNER_CHANGE:
            if (!strcmp(name, "owner")) {
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "reason")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->owner_change.reason);
            } else if (!strcmp(name, "selection")) { /* TODO GdkAtom is a struct */
                ALLOC_ZVAL(result);
                ZVAL_NULL(result);
            } else if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->owner_change.time);
            } else if (!strcmp(name, "selection_time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->owner_change.selection_time);
            }
            break;

        default:
            break;
    }

    if (!strcmp(name, "type")) {
        ALLOC_ZVAL(result);
        ZVAL_LONG(result, event->type);
    } else if (!strcmp(name, "window")) {
        ALLOC_ZVAL(result);
        phpg_gobject_new(&result, (GObject *)event->any.window TSRMLS_CC);
    } else if (!strcmp(name, "send_event")) {
        ALLOC_ZVAL(result);
        ZVAL_BOOL(result, event->any.send_event);
    }

    if (result) {
        result->refcount = 0;
        result->is_ref = 0;
    } else {
        result = zend_get_std_object_handlers()->read_property(object, member, type TSRMLS_CC);
    }

	if (member == &tmp_member) {
		zval_dtor(member);
	}

    return result;
}

%% }}}

%%
override-handler GdkEvent get_properties
HashTable* phpg_gdkevent_get_properties_handler(zval *object TSRMLS_DC)
{
    phpg_head_t *poh = NULL;
    GdkEvent *event = (GdkEvent *) PHPG_GBOXED(object);

    poh = (phpg_head_t *) zend_object_store_get_object(object TSRMLS_CC);

    switch (event->type) {

        case GDK_NOTHING:
        case GDK_DELETE:
        case GDK_DESTROY:
            break;

        case GDK_EXPOSE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(area), STRS(count), NULL);
            break;

        case GDK_MOTION_NOTIFY:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(x), STRS(y), STRS(axes),
                                       STRS(state), STRS(is_hint), STRS(device),
                                       STRS(x_root), STRS(y_root), NULL);
            break;

        case GDK_BUTTON_PRESS:
        case GDK_2BUTTON_PRESS:
        case GDK_3BUTTON_PRESS:
        case GDK_BUTTON_RELEASE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(x), STRS(y), STRS(axes),
                                       STRS(state), STRS(button), STRS(device),
                                       STRS(x_root), STRS(y_root), NULL);
            break;

        case GDK_KEY_PRESS:
        case GDK_KEY_RELEASE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(state), STRS(keyval), STRS(string),
                                       STRS(hardware_keycode), STRS(group), NULL);
            break;

        case GDK_ENTER_NOTIFY:
        case GDK_LEAVE_NOTIFY:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(subwindow), STRS(time), STRS(x), STRS(y),
                                       STRS(x_root), STRS(y_root), STRS(mode), STRS(detail),
                                       STRS(focus), STRS(state), NULL);
            break;

        case GDK_FOCUS_CHANGE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(in), NULL);

        case GDK_CONFIGURE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(x), STRS(y), STRS(width), STRS(height), NULL);
            break;

        case GDK_MAP:
        case GDK_UNMAP:
            break;

        case GDK_PROPERTY_NOTIFY:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(atom), STRS(time), STRS(state), NULL);
            break;

        case GDK_SELECTION_CLEAR:
        case GDK_SELECTION_REQUEST:
        case GDK_SELECTION_NOTIFY:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(selection), STRS(target), STRS(property),
                                       STRS(time), STRS(requestor), NULL);
            break;

        case GDK_PROXIMITY_IN:
        case GDK_PROXIMITY_OUT:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(device), NULL);
            break;

        case GDK_DRAG_ENTER:
        case GDK_DRAG_LEAVE:
        case GDK_DRAG_MOTION:
        case GDK_DRAG_STATUS:
        case GDK_DROP_START:
        case GDK_DROP_FINISHED:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC, STRS(context),
                                       STRS(time), STRS(x_root), STRS(y_root), NULL);
            break;

        case GDK_CLIENT_EVENT:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(message_type), STRS(data_format), STRS(data), NULL);
            break;

        case GDK_VISIBILITY_NOTIFY:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(state), NULL);
            break;

        case GDK_NO_EXPOSE:
            break;

        case GDK_SCROLL:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC, STRS(time),
                                       STRS(x), STRS(y), STRS(state), STRS(direction),
                                       STRS(device), STRS(x_root), STRS(y_root), NULL);
            break;

        case GDK_WINDOW_STATE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(changed_mask), STRS(new_window_state), NULL);
            break;

        case GDK_SETTING:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(action), STRS(name), NULL);
            break;

        case GDK_OWNER_CHANGE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC, STRS(owner),
                                       STRS(reason), STRS(selection), STRS(time), STRS(selection_time), NULL);
            break;

        default:
            break;
    }

    phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                               STRS(type), STRS(window), STRS(send_event), NULL);

	return poh->zobj.properties;
}


%%
add-arginfo GdkEvent get_axis
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, axis_type)
ZEND_END_ARG_INFO();

%%
override gdk_event_get_axis
PHP_METHOD
{
    zval *php_axis_use;
    GdkAxisUse axis_use;
    gdouble value;

    NO_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_axis_use))
        return;

    if (phpg_gvalue_get_enum(GDK_TYPE_AXIS_USE, php_axis_use, (gint *) &axis_use) == FAILURE)
        return;

    if (gdk_event_get_axis((GdkEvent *) PHPG_GBOXED(this_ptr), axis_use, &value)) {
        RETURN_DOUBLE(value);
    } else {
        RETURN_FALSE;
    }
}


%%
override gdk_event_get_coords
PHP_METHOD
{
    gdouble x_win, y_win;

    NO_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    if (gdk_event_get_coords((GdkEvent *) PHPG_GBOXED(this_ptr), &x_win, &y_win)) {
        php_gtk_build_value(&return_value, "(dd)", x_win, y_win);
    } else {
        RETURN_FALSE;
    }
}


%%
override gdk_event_get_root_coords
PHP_METHOD
{
    gdouble x_win, y_win;

    NO_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    if (gdk_event_get_root_coords((GdkEvent *) PHPG_GBOXED(this_ptr), &x_win, &y_win)) {
        php_gtk_build_value(&return_value, "(dd)", x_win, y_win);
    } else {
        RETURN_FALSE;
    }
}


%%
override gdk_event_get_state
PHP_METHOD
{
    GdkModifierType state = 0;

    NO_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_event_get_state((GdkEvent *) PHPG_GBOXED(this_ptr), &state);

    RETURN_LONG((long)state);
}

%% }}}


%% {{{ GdkPixbuf

%%
add-arginfo GdkPixbuf render_pixmap_and_mask
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, alpha_threshold)
ZEND_END_ARG_INFO();

%%
override gdk_pixbuf_render_pixmap_and_mask
PHP_METHOD
{
    int alpha_threshold = 127;
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    zval *php_pixmap = NULL;
    zval *php_mask = NULL;

    NOT_STATIC_METHOD();
    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|i", &alpha_threshold))
        return;

    gdk_pixbuf_render_pixmap_and_mask(GDK_PIXBUF(PHPG_GOBJECT(this_ptr)), &pixmap, &mask, alpha_threshold);
    if (pixmap) {
        phpg_gobject_new(&php_pixmap, (GObject*)pixmap TSRMLS_CC);
        gdk_pixmap_unref(pixmap);
    } else {                            
        MAKE_STD_ZVAL(php_pixmap);
    }

    if (mask) {
        phpg_gobject_new(&php_mask, (GObject *)mask TSRMLS_CC);
        gdk_bitmap_unref(mask);
    } else {
        MAKE_STD_ZVAL(php_mask);
    }

    php_gtk_build_value(&return_value, "(NN)", php_pixmap, php_mask);
}

%%override-prop GdkPixbuf pixel_array
PHPG_PROP_READER
{
    /* TODO */
    return SUCCESS;
}

%% }}}

%% {{{ GdkRectangle

%%
add-arginfo GdkRectangle __construct
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, x)
    ZEND_ARG_INFO(0, y)
    ZEND_ARG_INFO(0, width)
    ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO();

%%
override gdk_rectangle_new
PHP_METHOD
{
    phpg_gboxed_t *pobj = NULL;
    GdkRectangle rect = { 0, 0, 0, 0 };

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "iiii", &(rect.x), &(rect.y),
                            &(rect.width), &(rect.height))) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GdkRectangle);
    }

    pobj = zend_object_store_get_object(this_ptr TSRMLS_CC);
    pobj->gtype = GDK_TYPE_RECTANGLE;
    pobj->boxed = g_boxed_copy(GDK_TYPE_RECTANGLE, &rect);
    pobj->free_on_destroy = TRUE;
}

%%
add-arginfo GdkRectangle intersect
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, rect, GdkRectangle, 1)
ZEND_END_ARG_INFO();

%%
override gdk_rectangle_intersect
PHP_METHOD
{
    GdkRectangle rect, dest;
    zval *php_rect;

    NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_rect TSRMLS_CC))
		return;

    if (phpg_rectangle_from_zval(php_rect, &rect TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects area argument to be either a 4-element array or a GdkRectangle object", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    if (gdk_rectangle_intersect((GdkRectangle*)PHPG_GBOXED(this_ptr), &rect, &dest)) {
        phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_FALSE;
    }
}

%%
add-arginfo GdkRectangle union
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_OBJ_INFO(0, rect, GdkRectangle, 1)
ZEND_END_ARG_INFO();

%%
override gdk_rectangle_union
PHP_METHOD
{
    GdkRectangle rect, dest;
    zval *php_rect;

    NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_rect))
		return;

    if (phpg_rectangle_from_zval(php_rect, &rect TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects area argument to be either a 4-element array or a GdkRectangle object", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    gdk_rectangle_union((GdkRectangle*)PHPG_GBOXED(this_ptr), &rect, &dest);
    phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE TSRMLS_CC);
}

%% }}}

%% {{{ GdkWindow

%%
override gdk_window_at_pointer
PHP_METHOD
{
    gint x, y;
    GdkWindow *window;
    zval *php_window = NULL;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    window = gdk_window_at_pointer(&x, &y);

    if (window != NULL) {
        phpg_gboxed_new(&php_window, GDK_TYPE_WINDOW, &window, TRUE, TRUE TSRMLS_CC);
        php_gtk_build_value(&return_value, "(Nii)", php_window, x, y);
    } else {
        RETURN_FALSE;
    }
}


%%
override gdk_window_get_geometry
PHP_METHOD
{
    gint x, y, width, height, depth;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_window_get_geometry(GDK_WINDOW(PHPG_GOBJECT(this_ptr)), &x, &y, &width, &height, &depth);
    php_gtk_build_value(&return_value, "(iiiii)", x, y, width, height, depth);
}


%%
override gdk_window_get_origin
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_window_get_origin(GDK_WINDOW(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}


%%
override gdk_window_get_pointer
PHP_METHOD(GdkWindow, get_pointer)
{
    int x, y = 0;
    GdkModifierType mask = 0;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_window_get_pointer(GDK_WINDOW(PHPG_GOBJECT(this_ptr)), &x, &y, &mask);
    php_gtk_build_value(&return_value, "(iii)", x, y, mask);
}


%%
override gdk_window_get_position
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_window_get_position(GDK_WINDOW(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}


%%
override gdk_window_get_root_origin
PHP_METHOD
{
    gint x, y;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), ""))
        return;

    gdk_window_get_root_origin(GDK_WINDOW(PHPG_GOBJECT(this_ptr)), &x, &y);
    php_gtk_build_value(&return_value, "(ii)", x, y);
}

%% }}}

%%
override gdk_text_extents
PHP_METHOD
{
	char *text;
	int length, lbearing, rbearing, width, ascent, descent;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s#", &text, &length))
		return;

    gdk_text_extents((GdkFont *)PHPG_GBOXED(this_ptr), text, length, &lbearing, &rbearing, &width, &ascent, &descent);
    php_gtk_build_value(&return_value, "(iiiii)", lbearing, rbearing, width, ascent, descent);
}

%%
override-prop GdkDrawable xid
PHPG_PROP_READER
{
#if defined(GDK_WINDOWING_X11)
	RETVAL_LONG(GDK_DRAWABLE_XID(((GdkDrawable *)((phpg_gobject_t *)object)->obj)));
#else
    RETVAL_LONG((long) GDK_WINDOW_HWND((GdkDrawable *)((phpg_gobject_t *)object)->obj));
#endif
    return SUCCESS;
}

%%
override gdk_atom_intern
PHP_METHOD
{
    char *atom_name;
	zend_bool free_atom_name, only_if_exists = FALSE;
	GdkAtom php_atom;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "u|b", &atom_name, &free_atom_name, &only_if_exists))
		return;

    php_atom = gdk_atom_intern(atom_name, (gboolean)only_if_exists);
	if (free_atom_name) g_free(atom_name);
    if (php_atom == GDK_NONE) {
        RETURN_NULL();
    }
    phpg_gdkatom_new(&return_value, php_atom TSRMLS_CC);
}

