/* vim: set ft=cpp fdm=marker et: */
/* TODO
 * fix gdk_gc_new2
 */
%%
headers
#include <gdk-pixbuf/gdk-pixbuf.h>

#if defined(GDK_WINDOWING_X11)
#include <gdk/gdkx.h>
#elif defined(GDK_WINDOWING_WIN32)
#include <gdk/gdkwin32.h>
#endif

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

#define MAX_INTENSITY 65535

/* Forward declaration, since gen_gtk.h is generated later. */
extern PHP_GTK_EXPORT_CE(gtkwidget_ce);

#include "gen_pango.h"

static inline int clamp_int(int value, int low, int high)
{
    return (value < low ? low : (value > high ? high : value));
}

static ZEND_METHOD(GdkColormap, alloc_color);

/* {{{ ignores */
%%
ignore-glob
    *_get_type

%%
ignore
    GdkDebugFlag
    GdkColorInfoFlags
%%
ignore
    gdk_pixmap_new
    gdk_gc_new2

/* }}} */

%% {{{ GdkColor

%%
add-arginfo GdkColor __construct
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, red)
    ZEND_ARG_INFO(0, blue)
    ZEND_ARG_INFO(0, green)
    ZEND_ARG_INFO(0, allocated)
ZEND_END_ARG_INFO();

%%
override gdk_color_new
PHP_METHOD
{
    guint red = 0;
    guint green = 0;
    guint blue = 0;
    guint pixel = 0;
    GdkColor color;
    phpg_gboxed_t *pobj = NULL;

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|iiii", &red, &green, &blue, &pixel))
        return;

    color.red = clamp_int(red, 0, MAX_INTENSITY);
    color.green = clamp_int(green, 0, MAX_INTENSITY);
    color.blue = clamp_int(blue, 0, MAX_INTENSITY);
    color.pixel = pixel;

    pobj = zend_object_store_get_object(this_ptr TSRMLS_CC);
    pobj->gtype = GDK_TYPE_COLOR;
    pobj->boxed = g_boxed_copy(GDK_TYPE_COLOR, &color);
    pobj->free_on_destroy = TRUE;
}

%%
add-arginfo GdkColor parse
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, color)
ZEND_END_ARG_INFO();


%%
override gdk_color_parse parse ZEND_ACC_PUBLIC|ZEND_ACC_STATIC
PHP_METHOD
{
	gchar *color_spec;
	GdkColor color;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s", &color_spec)) {
		return;
	}

	if (gdk_color_parse(color_spec, &color)) {
        phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);
    } else {
        php_error(E_WARNING, "%s::%s() could not parse color spec '%s'",
                  get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), color_spec);
        RETURN_FALSE;
    }
}

%%
override-prop GdkColor red
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->red);
    return SUCCESS;
}
%%
override-prop GdkColor green
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->green);
    return SUCCESS;
}
%%
override-prop GdkColor blue
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->blue);
    return SUCCESS;
}
%%
override-prop GdkColor pixel
PHPG_PROP_READER
{
	RETVAL_LONG(((GdkColor *)((phpg_gboxed_t *)object)->boxed)->pixel);
    return SUCCESS;
}

%%
override-handler GdkColor write_property
void phpg_gdkcolor_write_property_handler(zval *object, zval *member, zval *value TSRMLS_DC)
{
    zval tmp_value;
	zval tmp_member;
    GdkColor *color;

 	if (member->type != IS_STRING) {
		tmp_member = *member;
		zval_copy_ctor(&tmp_member);
		convert_to_string(&tmp_member);
		member = &tmp_member;
	}

    if (value->type != IS_LONG) {
        tmp_value = *value;
        zval_copy_ctor(&tmp_value);
        convert_to_long(&tmp_value);
        value = &tmp_value;
    }

    color = (GdkColor *)PHPG_GBOXED(object);
    if (!strcmp(Z_STRVAL_P(member), "pixel")) {
        color->pixel = Z_LVAL_P(value);
    } else {
        if (!strcmp(Z_STRVAL_P(member), "red")) {
            color->red = clamp_int(Z_LVAL_P(value), 0, MAX_INTENSITY);
        } else if (!strcmp(Z_STRVAL_P(member), "green")) {
            color->green = clamp_int(Z_LVAL_P(value), 0, MAX_INTENSITY);
        } else if (!strcmp(Z_STRVAL_P(member), "blue")) {
            color->blue = clamp_int(Z_LVAL_P(value), 0, MAX_INTENSITY);
        }
    }

	if (member == &tmp_member) {
		zval_dtor(member);
	}
	if (value == &tmp_value) {
		zval_dtor(value);
	}
}

%%
override-handler GdkColor get_properties
HashTable* phpg_gdkcolor_get_properties_handler(zval *object TSRMLS_DC)
{
    phpg_head_t *poh = NULL;
    poh = (phpg_head_t *) zend_object_store_get_object(object TSRMLS_CC);
    phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                               STRS(red), STRS(green), STRS(blue), STRS(pixel), NULL);

	return poh->zobj.properties;
}

%%
override gdk_color_alloc
PHP_METHOD
{
	phpg_warn_deprecated("use GdkColormap::alloc_color()" TSRMLS_CC);
    PHP_FN(GdkColormap_alloc_color)(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}
%% }}}

%% {{{ GdkColormap

%%
add-arginfo GdkColormap alloc_color
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, color OR red)
    ZEND_ARG_INFO(0, blue)
    ZEND_ARG_INFO(0, green)
ZEND_END_ARG_INFO();

%%
override gdk_colormap_alloc_color
PHP_METHOD
{
    GdkColor color = { 0, 0, 0, 0 };
    guint red = 0, green = 0, blue = 0;
    zend_bool writeable = FALSE;
    zend_bool best_match = TRUE;
    zval *php_color;
	gchar *color_spec;

    NOT_STATIC_METHOD();

    if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "iii|bb", &red, &green, &blue, &writeable, &best_match)) {
        color.red = clamp_int(red, 0, MAX_INTENSITY);
        color.green = clamp_int(green, 0, MAX_INTENSITY);
        color.blue = clamp_int(blue, 0, MAX_INTENSITY);
    } else if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "O|bb",
                                        &php_color, gdkcolor_ce, &writeable, &best_match)) {
        color = *(GdkColor*)PHPG_GBOXED(php_color);
    } else if (php_gtk_parse_args_quiet(ZEND_NUM_ARGS(), "s|bb", &color_spec, &writeable, &best_match)) {
        if (!gdk_color_parse(color_spec, &color)) {
            php_error(E_WARNING, "%s::%s() could not parse color spec '%s'",
                      get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C), color_spec);
            RETURN_FALSE;
        }
    } else {
            php_error(E_WARNING, "%s::%s() requires color to be specified as an RGB triplet, GdkColor, or a string", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
    }

	if (!gdk_colormap_alloc_color(GDK_COLORMAP(PHPG_GOBJECT(this_ptr)), &color, writeable, best_match)) {
        php_error(E_WARNING, "%s::%s() could not allocate color", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        RETURN_FALSE;
	}

    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);
}

%%
add-arginfo GdkColormap query_color
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, allocated)
ZEND_END_ARG_INFO();

%%
override gdk_colormap_query_color
PHP_METHOD
{
    GdkColor color = { 0 , 0 , 0 , 0 };
    guint pixel;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i", &pixel))
        return;
    gdk_colormap_query_color(GDK_COLORMAP(PHPG_GOBJECT(this_ptr)), pixel, &color);
    phpg_gboxed_new(&return_value, GDK_TYPE_COLOR, &color, TRUE, TRUE TSRMLS_CC);
}

%% }}}

%% {{{ GdkEvent

%%
override-handler GdkEvent read_property
static zval* phpg_gdkevent_read_property_handler(zval *object, zval *member, int type TSRMLS_DC)
{
    zval tmp_member;
    zval *result = NULL;
    GdkEvent *event = (GdkEvent *) PHPG_GBOXED(object);
    char *name;

	if (member->type != IS_STRING) {
		tmp_member = *member;
		zval_copy_ctor(&tmp_member);
		convert_to_string(&tmp_member);
		member = &tmp_member;
	}

    name = Z_STRVAL_P(member);

    /* TODO
     * the rest of event types
     */
    switch (event->type) {
        case GDK_EXPOSE:
            if (!strcmp(name, "area")) {
                phpg_gboxed_new(&result, GDK_TYPE_RECTANGLE, &event->expose.area, TRUE, TRUE TSRMLS_CC);
            } else if (!strcmp(name, "count")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->expose.count);
            }
            break;

        case GDK_BUTTON_PRESS:
        case GDK_2BUTTON_PRESS:
        case GDK_3BUTTON_PRESS:
        case GDK_BUTTON_RELEASE:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->button.time);
            } else if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.y);
            } else if (!strcmp(name, "axes")) {
                ALLOC_ZVAL(result);
                if (event->button.axes) {
                    guint i = 0;
                    array_init(result);
                    for (i = 0; i < event->button.device->num_axes; i++) {
                        add_next_index_double(result, event->button.axes[i]);
                    }
                } else {
                    ZVAL_NULL(result);
                }
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->button.state);
            } else if (!strcmp(name, "button")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->button.button);
            } else if (!strcmp(name, "device")) {
                phpg_gobject_new(&result, (GObject*)event->button.device TSRMLS_CC);
            } else if (!strcmp(name, "x_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.x_root);
            } else if (!strcmp(name, "y_root")) {
                ALLOC_ZVAL(result);
                ZVAL_DOUBLE(result, event->button.y_root);
            }
            break;

        case GDK_KEY_PRESS:
        case GDK_KEY_RELEASE:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.time);
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.state);
            } else if (!strcmp(name, "keyval")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.keyval);
            } else if (!strcmp(name, "string")) {
                ALLOC_ZVAL(result);
                ZVAL_STRINGL(result, event->key.string, event->key.length, 1);
            } else if (!strcmp(name, "hardware_keycode")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.hardware_keycode);
            } else if (!strcmp(name, "group")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.group);
            }
            break;

        case GDK_CONFIGURE:
            if (!strcmp(name, "x")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.x);
            } else if (!strcmp(name, "y")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.y);
            } else if (!strcmp(name, "width")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.width);
            } else if (!strcmp(name, "height")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->configure.height);
            }
            break;

        case GDK_NOTHING:
        case GDK_DELETE:
        case GDK_DESTROY:
        case GDK_MAP:
        case GDK_UNMAP:
        case GDK_NO_EXPOSE:
        default:
            break;
    }

    if (!strcmp(name, "type")) {
        ALLOC_ZVAL(result);
        ZVAL_LONG(result, event->type);
    } else if (!strcmp(name, "window")) {
        ALLOC_ZVAL(result);
        phpg_gobject_new(&result, (GObject *)event->any.window TSRMLS_CC);
    } else if (!strcmp(name, "send_event")) {
        ALLOC_ZVAL(result);
        ZVAL_BOOL(result, event->any.send_event);
    }

    if (result) {
        result->refcount = 0;
        result->is_ref = 0;
    } else {
        result = zend_get_std_object_handlers()->read_property(object, member, type TSRMLS_CC);
    }

	if (member == &tmp_member) {
		zval_dtor(member);
	}

    return result;
}

%%
override-handler GdkEvent get_properties
HashTable* phpg_gdkevent_get_properties_handler(zval *object TSRMLS_DC)
{
    phpg_head_t *poh = NULL;
    GdkEvent *event = (GdkEvent *) PHPG_GBOXED(object);

    poh = (phpg_head_t *) zend_object_store_get_object(object TSRMLS_CC);

    /* TODO
     * the rest of event types
     */
    switch (event->type) {
        case GDK_EXPOSE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(area), STRS(count), NULL);
            break;

        case GDK_BUTTON_PRESS:
        case GDK_2BUTTON_PRESS:
        case GDK_3BUTTON_PRESS:
        case GDK_BUTTON_RELEASE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(x), STRS(y), STRS(axes),
                                       STRS(state), STRS(button), STRS(device),
                                       STRS(x_root), STRS(y_root), NULL);
            break;

        case GDK_KEY_PRESS:
        case GDK_KEY_RELEASE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(state), STRS(keyval), STRS(string),
                                       STRS(hardware_keycode), STRS(group), NULL);
            break;

        case GDK_CONFIGURE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(x), STRS(y), STRS(width), STRS(height), NULL);
            break;

        case GDK_NOTHING:
        case GDK_DELETE:
        case GDK_DESTROY:
        case GDK_MAP:
        case GDK_UNMAP:
        case GDK_NO_EXPOSE:
        default:
            break;
    }

    phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                               STRS(type), STRS(window), STRS(send_event), NULL);

	return poh->zobj.properties;
}

%% }}}

%% {{{ GdkPixbuf

%%
add-arginfo GdkPixbuf render_pixmap_and_mask
static
ZEND_BEGIN_ARG_INFO_EX(ARGINFO_NAME, 0, 0, 0)
    ZEND_ARG_INFO(0, alpha_treshold)
ZEND_END_ARG_INFO();

%%
override gdk_pixbuf_render_pixmap_and_mask
PHP_METHOD
{
    int alpha_threshold = 127;
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    zval *php_pixmap = NULL;
    zval *php_mask = NULL;

    NOT_STATIC_METHOD();
    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "|i", &alpha_threshold))
        return;

    gdk_pixbuf_render_pixmap_and_mask(GDK_PIXBUF(PHPG_GOBJECT(this_ptr)), &pixmap, &mask, alpha_threshold);
    if (pixmap) {
        phpg_gobject_new(&php_pixmap, (GObject*)pixmap TSRMLS_CC);
        gdk_pixmap_unref(pixmap);
    } else {                            
        MAKE_STD_ZVAL(php_pixmap);
    }

    if (mask) {
        phpg_gobject_new(&php_mask, (GObject*)mask TSRMLS_CC);
        gdk_bitmap_unref(mask);
    } else {
        MAKE_STD_ZVAL(php_mask);
    }

    php_gtk_build_value(&return_value, "(NN)", php_pixmap, php_mask);
}

%%override-prop GdkPixbuf pixel_array
PHPG_PROP_READER
{
    /* TODO */
    return SUCCESS;
}

%% }}}

%% {{{ GdkRectangle

%%
add-arginfo GdkRectangle __construct
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, x)
    ZEND_ARG_INFO(0, y)
    ZEND_ARG_INFO(0, width)
    ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO();

%%
override gdk_rectangle_new
PHP_METHOD
{
    phpg_gboxed_t *pobj = NULL;
    GdkRectangle rect = { 0, 0, 0, 0 };

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "iiii", &(rect.x), &(rect.y),
                            &(rect.width), &(rect.height))) {
        PHPG_THROW_CONSTRUCT_EXCEPTION(GdkRectangle);
    }

    pobj = zend_object_store_get_object(this_ptr TSRMLS_CC);
    pobj->gtype = GDK_TYPE_RECTANGLE;
    pobj->boxed = g_boxed_copy(GDK_TYPE_RECTANGLE, &rect);
    pobj->free_on_destroy = TRUE;
}

%%
add-arginfo GdkRectangle intersect
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, rect)
ZEND_END_ARG_INFO();

%%
override gdk_rectangle_intersect
PHP_METHOD
{
    GdkRectangle rect, dest;
    zval *php_rect;

    NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_rect TSRMLS_CC))
		return;

    if (phpg_rectangle_from_zval(php_rect, &rect TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects area argument to be either a 4-element array or a GdkRectangle object", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    if (gdk_rectangle_intersect((GdkRectangle*)PHPG_GBOXED(this_ptr), &rect, &dest)) {
        phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE TSRMLS_CC);
    } else {
        RETURN_FALSE;
    }
}

%%
add-arginfo GdkRectangle union
static
ZEND_BEGIN_ARG_INFO(ARGINFO_NAME, 0)
    ZEND_ARG_INFO(0, rect)
ZEND_END_ARG_INFO();

%%
override gdk_rectangle_union
PHP_METHOD
{
    GdkRectangle rect, dest;
    zval *php_rect;

    NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "V", &php_rect))
		return;

    if (phpg_rectangle_from_zval(php_rect, &rect TSRMLS_CC) == FAILURE) {
        php_error(E_WARNING, "%s::%s() expects area argument to be either a 4-element array or a GdkRectangle object", get_active_class_name(NULL TSRMLS_CC), get_active_function_name(TSRMLS_C));
        return;
    }

    gdk_rectangle_union((GdkRectangle*)PHPG_GBOXED(this_ptr), &rect, &dest);
    phpg_gboxed_new(&return_value, GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE TSRMLS_CC);
}

%% }}}

%%
override gdk_text_extents
PHP_METHOD
{
	char *text;
	int length, lbearing, rbearing, width, ascent, descent;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s#", &text, &length))
		return;

    gdk_text_extents((GdkFont *)PHPG_GBOXED(this_ptr), text, length, &lbearing, &rbearing, &width, &ascent, &descent);
    php_gtk_build_value(&return_value, "(iiiii)", lbearing, rbearing, width, ascent, descent);
}

%%
override-prop GdkDrawable xid
PHPG_PROP_READER
{
#if defined(GDK_WINDOWING_X11)
	RETVAL_LONG(GDK_DRAWABLE_XID(((GdkDrawable *)((phpg_gobject_t *)object)->obj)));
#else
    php_error(E_WARNING, "xid property is not supported");
#endif
    return SUCCESS;
}
