/* vim: set ft=cpp fdm=marker et: */
/* TODO
 * fix gdk_gc_new2
 */
%%
headers
#include <gdk-pixbuf/gdk-pixbuf.h>

#if defined(GDK_WINDOWING_X11)
#include <gdk/gdkx.h>
#elif defined(GDK_WINDOWING_WIN32)
#include <gdk/gdkwin32.h>
#endif

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

/* Forward declaration, since gen_gtk.h is generated later. */
extern PHP_GTK_EXPORT_CE(gtkwidget_ce);

#include "gen_pango.h"

/* {{{ ignores */
%%
ignore-glob
    *_get_type

%%
ignore
    GdkDebugFlag
    GdkColorInfoFlags
%%
ignore
    gdk_pixmap_new
    gdk_gc_new2

/* }}} */

%%
override gdk_color_new
PHP_METHOD
{
    /* TODO */
}

%%
override gdk_text_extents
PHP_METHOD
{
	char *text;
	int length, lbearing, rbearing, width, ascent, descent;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "s#", &text, &length))
		return;

    gdk_text_extents((GdkFont *)PHPG_GBOXED(this_ptr), text, length, &lbearing, &rbearing, &width, &ascent, &descent);
    php_gtk_build_value(&return_value, "(iiiii)", lbearing, rbearing, width, ascent, descent);
}

%%
override gdk_rectangle_new
PHP_METHOD
{
    phpg_gboxed_t *pobj = NULL;
    GdkRectangle rect = { 0, 0, 0, 0 };

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "iiii", &(rect.x), &(rect.y),
                            &(rect.width), &(rect.height))) {
        PHPG_THROW_CONSTRUCT_EXCEPTION();
    }

    pobj = zend_object_store_get_object(this_ptr TSRMLS_CC);
    pobj->gtype = GDK_TYPE_RECTANGLE;
    pobj->boxed = g_boxed_copy(GDK_TYPE_RECTANGLE, &rect);
    pobj->free_on_destroy = TRUE;
}

%%
override gdk_rectangle_intersect
PHP_METHOD
{
    /* TODO */
}

%%
override-prop GdkDrawable xid
PHPG_PROP_READER
{
#if defined(GDK_WINDOWING_X11)
	RETVAL_LONG(GDK_DRAWABLE_XID(((GdkDrawable *)((phpg_gobject_t *)object)->obj)));
#else
    php_error(E_WARNING, "xid property is not supported");
#endif
    return SUCCESS;
}

%%override-prop GdkPixbuf pixel_array
PHPG_PROP_READER
{
    /* TODO */
    return SUCCESS;
}

%%
override-handler GdkEvent read_property
static zval* phpg_gdkevent_read_property_handler(zval *object, zval *member, int type TSRMLS_DC)
{
    zval tmp_member;
    zval *result = NULL;
    GdkEvent *event = (GdkEvent *) PHPG_GBOXED(object);
    char *name;

 	if (member->type != IS_STRING) {
		tmp_member = *member;
		zval_copy_ctor(&tmp_member);
		convert_to_string(&tmp_member);
		member = &tmp_member;
	}

    name = Z_STRVAL_P(member);

    /* TODO
     * the rest of event types
     */
    switch (event->type) {
        case GDK_NOTHING:
        case GDK_DELETE:
        case GDK_DESTROY:
            break;

        case GDK_EXPOSE:
            if (!strcmp(name, "area")) {
                phpg_gboxed_new(&result, GDK_TYPE_RECTANGLE, &event->expose.area, TRUE, TRUE TSRMLS_CC);
            } else if (!strcmp(name, "count")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->expose.count);
            }
            break;

        case GDK_KEY_PRESS:
        case GDK_KEY_RELEASE:
            if (!strcmp(name, "time")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.time);
            } else if (!strcmp(name, "state")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.state);
            } else if (!strcmp(name, "keyval")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.keyval);
            } else if (!strcmp(name, "string")) {
                ALLOC_ZVAL(result);
                ZVAL_STRINGL(result, event->key.string, event->key.length, 1);
            } else if (!strcmp(name, "hardware_keycode")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.hardware_keycode);
            } else if (!strcmp(name, "group")) {
                ALLOC_ZVAL(result);
                ZVAL_LONG(result, event->key.group);
            }
            break;

        default:
            break;
    }

    if (!strcmp(name, "type")) {
        ALLOC_ZVAL(result);
        ZVAL_LONG(result, event->type);
    } else if (!strcmp(name, "window")) {
        ALLOC_ZVAL(result);
        phpg_gobject_new(&result, (GObject *)event->any.window TSRMLS_CC);
    } else if (!strcmp(name, "send_event")) {
        ALLOC_ZVAL(result);
        ZVAL_BOOL(result, event->any.send_event);
    }

    if (result) {
        result->refcount = 0;
        result->is_ref = 0;
    } else {
        result = zend_get_std_object_handlers()->read_property(object, member, type TSRMLS_CC);
    }

	if (member == &tmp_member) {
		zval_dtor(member);
	}

    return result;
}

%%
override-handler GdkEvent get_properties
HashTable* phpg_gdkevent_get_properties_handler(zval *object TSRMLS_DC)
{
    phpg_head_t *poh = NULL;
    GdkEvent *event = (GdkEvent *) PHPG_GBOXED(object);

    poh = (phpg_head_t *) zend_object_store_get_object(object TSRMLS_CC);

    /* TODO
     * the rest of event types
     */
    switch (event->type) {
        case GDK_KEY_PRESS:
        case GDK_KEY_RELEASE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(time), STRS(state), STRS(keyval), STRS(string),
                                       STRS(hardware_keycode), STRS(group), NULL);
            break;

        case GDK_EXPOSE:
            phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                                       STRS(area), STRS(count), NULL);
            break;

        case GDK_NOTHING:
        case GDK_DELETE:
        case GDK_DESTROY:
        default:
            break;
    }

    phpg_get_properties_helper(object, poh->zobj.properties TSRMLS_CC,
                               STRS(type), STRS(window), STRS(send_event), NULL);

	return poh->zobj.properties;
}
