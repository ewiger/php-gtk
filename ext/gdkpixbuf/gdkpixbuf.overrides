/* vim: set ft=cpp: */
%%
headers
#include "php_gdkpixbuf.h"
%%
ignore
  gdk_pixbuf_preinit
  gdk_pixbuf_postinit

%%
override gdk_pixbuf_new_from_data
PHP_FUNCTION(gdk_pixbuf_new_from_data)
{
	zval *data;
	GdkColorspace colorspace;
	zval *php_colorspace = NULL;
	zend_bool has_alpha;
	long bits_per_sample, width, height, rowstride;

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "VVbiiii", &data, &php_colorspace, &has_alpha, &bits_per_sample, &width, &height, &rowstride))
		return;

	convert_to_string(data);
	zval_add_ref(&data);

	if (php_colorspace && !php_gtk_get_simple_enum_value(php_colorspace, (gint *)&colorspace)) {
		return;
	}

	PHP_GTK_SEPARATE_RETURN(return_value, php_gdk_pixbuf_new(gdk_pixbuf_new_from_data(Z_STRVAL_P(data), colorspace, (gboolean)has_alpha, (int)bits_per_sample, (int)width, (int)height, (int)rowstride, (GdkPixbufDestroyNotify)php_gtk_destroy_notify, data)));
}

%%
override gdk_pixbuf_render_pixmap_and_mask
PHP_FUNCTION(gdk_pixbuf_render_pixmap_and_mask)
{
	int alpha_threshold;
	GdkPixmap *pixmap;
	GdkBitmap *mask;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i", &alpha_threshold))
		return;

	gdk_pixbuf_render_pixmap_and_mask(PHP_GDK_PIXBUF_GET(this_ptr), &pixmap,
									  &mask, alpha_threshold);

	*return_value = *php_gtk_build_value("(NN)", php_gdk_pixmap_new(pixmap),
										 php_gdk_bitmap_new(mask));
}
%%
override gdk_pixbuf_fill fill GdkPixbuf
PHP_FUNCTION(gdk_pixbuf_fill)
{
	unsigned int color;
	int x, y, width, height, rowstride, n_chan;
	guchar *pixels;
	gboolean alpha;
	GdkPixbuf *pixbuf;
	guchar *p, *row;

	NOT_STATIC_METHOD();

	if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "i", &color))
		return;

	pixbuf    = PHP_GDK_PIXBUF_GET(this_ptr);
	width     = gdk_pixbuf_get_width(pixbuf);
	height    = gdk_pixbuf_get_height(pixbuf);
	pixels    = gdk_pixbuf_get_pixels(pixbuf);
	rowstride = gdk_pixbuf_get_rowstride(pixbuf);
	n_chan    = gdk_pixbuf_get_n_channels(pixbuf);
	alpha     = gdk_pixbuf_get_has_alpha(pixbuf);

	row = pixels;
	for (y = 0; y < height; y++, row += rowstride) {
		p = row;
		if (alpha) {
			for (x = 0; x < width; x++, p += n_chan) {
				p[0] = color >> 24;
				p[1] = color >> 16;
				p[2] = color >> 8;
				p[3] = color;
			}
		} else {
			for (x = 0; x < width; x++, p += n_chan) {
				p[0] = color >> 16;
				p[1] = color >> 8;
				p[2] = color;
			}
		}
	}
}
%%
override gdk_pixbuf_new
PHP_FUNCTION(gdk_pixbuf_new)
{
    long width, height;
    zend_bool has_alpha;
    GdkPixbuf *wrapped_obj;

    NOT_STATIC_METHOD();

    if (!php_gtk_parse_args(ZEND_NUM_ARGS(), "iib", &width, &height, &has_alpha)) {
        php_gtk_invalidate(this_ptr);
        return;
    }

    wrapped_obj = (GdkPixbuf *)gdk_pixbuf_new(GDK_COLORSPACE_RGB, (gboolean)has_alpha, 8, (int)width, (int)height);
    if (!wrapped_obj) {
        php_error(E_WARNING, "%s(): could not create GdkPixbuf object",
                  get_active_function_name(TSRMLS_C));
        php_gtk_invalidate(this_ptr);
        return;
    }

    php_gtk_set_object(this_ptr, wrapped_obj, le_gdk_pixbuf, 1);

}
